<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Greeting Card Creator</title>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;700&family=Great+Vibes&family=Inter:wght@300;400;500;600;700&family=Lobster&family=Merriweather:wght@300;400;700&family=Open+Sans:wght@400;600;700&family=Pacifico&family=Playfair+Display:ital,wght@0,400;0,700;1,400&display=swap"
        rel="stylesheet">

    <!-- Three.js & Dependencies via CDN -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://esm.sh/three@0.160.0",
          "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/",
          "@aws-amplify/core": "https://esm.sh/@aws-amplify/core@6.0.12",
          "aws-amplify": "https://esm.sh/aws-amplify@6.0.12?deps=@aws-amplify/core@6.0.12",
          "aws-amplify/auth": "https://esm.sh/aws-amplify@6.0.12/auth?deps=@aws-amplify/core@6.0.12",
          "aws-amplify/storage": "https://esm.sh/aws-amplify@6.0.12/storage?deps=@aws-amplify/core@6.0.12",
          "aws-amplify/utils": "https://esm.sh/aws-amplify@6.0.12/utils?deps=@aws-amplify/core@6.0.12"
        }
      }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/localforage/1.10.0/localforage.min.js"></script>

    <style>
        :root {
            --bg-color: #121212;
            --panel-bg: rgba(30, 30, 30, 0.7);
            --panel-border: rgba(255, 255, 255, 0.1);
            --accent-color: #646cff;
            --accent-hover: #7b83ff;
            --text-main: #ffffff;
            --text-sec: #aaaaaa;
            --glass-blur: 12px;
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background: radial-gradient(circle at 50% 50%, #2a2a2a 0%, #121212 100%);
            color: var(--text-main);
            width: 100vw;
            height: 100vh;
        }

        #app {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
        }

        /* 3D Viewport */
        #viewport {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
        }

        #three-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 1000;
        }

        /* Sidebar Panels */
        .panel {
            width: 300px;
            background: var(--panel-bg);
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            border-right: 1px solid var(--panel-border);
            display: flex;
            flex-direction: column;
            padding: 20px;
            box-sizing: border-box;
            z-index: 10;
            transition: transform 0.3s ease;
        }

        .panel-right {
            border-right: none;
            border-left: 1px solid var(--panel-border);
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
        }

        h2,
        h3 {
            margin-top: 0;
            font-weight: 500;
            color: var(--text-main);
        }

        h3 {
            font-size: 1rem;
            color: var(--text-sec);
            margin-top: 1rem;
        }

        /* Controls */
        button {
            background: #333;
            color: white;
            border: 1px solid var(--panel-border);
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            margin-bottom: 8px;
            transition: background 0.2s;
            font-family: inherit;
        }

        button:hover {
            background: #444;
        }

        button.primary {
            background: var(--accent-color);
            border-color: var(--accent-color);
        }

        button.primary:hover {
            background: var(--accent-hover);
        }

        .control-group {
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        label {
            font-size: 0.85rem;
            color: var(--text-sec);
            margin-bottom: 4px;
            display: block;
        }

        input[type="text"],
        input[type="number"],
        select {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--panel-border);
            color: white;
            padding: 8px;
            border-radius: 4px;
            width: 100%;
            box-sizing: border-box;
        }

        /* Asset Grid */
        .asset-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 10px;
            overflow-y: auto;
            flex-grow: 1;
            padding-right: 5px;
        }

        .asset-item {
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            cursor: grab;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid transparent;
        }

        .asset-item:hover {
            border-color: var(--accent-color);
        }

        .asset-item img {
            max-width: 100%;
            max-height: 100%;
            pointer-events: none;
        }

        /* View Mode Toggles */
        .view-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: max-content;
            max-width: 90%;
            background: var(--panel-bg);
            backdrop-filter: blur(var(--glass-blur));
            padding: 10px;
            border-radius: 30px;
            display: flex;
            gap: 10px;
            border: 1px solid var(--panel-border);
            z-index: 20;
        }

        .view-btn {
            background: transparent;
            border: none;
            color: var(--text-sec);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
        }

        .view-btn.active {
            background: var(--accent-color);
            color: white;
        }

        /* Hidden Canvas */
        .offscreen-canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            opacity: 0;
            pointer-events: none;
            z-index: -1;
        }

        /* Animation Range */
        #anim-control {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 20;
            background: var(--panel-bg);
            padding: 8px 16px;
            border-radius: 20px;
            backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--panel-border);
        }

        #btn-brightness-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 20;
            background: var(--panel-bg);
            backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--panel-border);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.9rem;
        }

        #btn-brightness-toggle:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        input[type="range"] {
            accent-color: var(--accent-color);
        }

        /* Mobile UI Buttons */
        .mobile-toggle {
            display: none;
            /* Hidden on desktop */
            position: absolute;
            top: 20px;
            z-index: 100;
            background: var(--panel-bg);
            backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--panel-border);
            color: white;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            font-size: 1.2rem;
            width: 44px;
            height: 44px;
            /* Touch target */
            align-items: center;
            justify-content: center;
        }

        #btn-toggle-left {
            left: 20px;
        }

        #btn-toggle-right {
            right: 20px;
        }

        /* Overlay for mobile drawer backdrop */
        #mobile-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 150;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        #mobile-backdrop.active {
            opacity: 1;
            pointer-events: auto;
        }

        @media (max-width: 768px) {
            #app {
                flex-direction: column;
            }

            /* Main Layout */
            #viewport {
                width: 100vw;
                height: 100vh;
                position: absolute;
                top: 0;
                left: 0;
                z-index: 1;
            }

            /* Panels as Drawers */
            .panel {
                position: fixed;
                top: 0;
                bottom: 0;
                width: 85%;
                max-width: 320px;
                height: 100%;
                left: 0;
                transform: translateX(-110%);
                /* Default Hidden */
                z-index: 200;
                border: none;
                border-right: 1px solid var(--panel-border);
                box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
                overflow-y: auto;
                transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            }

            .panel-right {
                left: auto;
                right: 0;
                transform: translateX(110%);
                border-left: 1px solid var(--panel-border);
                border-right: none;
            }

            .panel.open {
                transform: translateX(0);
            }

            .panel-right.open {
                transform: translateX(0);
            }

            /* View Controls */
            .view-controls {
                width: 90%;
                flex-wrap: wrap;
                justify-content: center;
                bottom: 40px;
                /* Higher up to avoid safe area */
                padding: 10px;
            }

            .view-btn {
                font-size: 0.8rem;
                padding: 10px 14px;
                flex-grow: 1;
                text-align: center;
            }

            /* Mobile Toggles */
            .mobile-toggle {
                display: flex;
            }

            /* Adjust Text/Inputs for Touch */
            button,
            input,
            select {
                min-height: 44px;
                /* Touch target */
                font-size: 16px;
                /* Stop iOS zoom */
            }

            h2 {
                font-size: 1.2rem;
            }

            /* Hide Anim control on mobile? Takes up space. Let's position it lower. */
            #anim-control {
                top: 70px;
            }
        }

        .toolbar-icon {
            margin-right: 5px;
        }

        .hidden {
            display: none !important;
        }

        /* File Input hidden */
        #file-input {
            display: none;
        }

        /* Draggable highlight on canvas */
        .drag-over {
            box-shadow: inset 0 0 20px var(--accent-color);
        }
    </style>
</head>

<body>
    <div id="loading-overlay">
        <h2>Loading 3D Engine...</h2>
        <div id="loading-msg" style="color:var(--text-sec); font-size:0.9rem;">Connecting to libraries...</div>
    </div>

    <!-- Mobile Toggles -->
    <button id="btn-toggle-left" class="mobile-toggle">‚ò∞</button>
    <button id="btn-toggle-right" class="mobile-toggle">‚öôÔ∏è</button>
    <div id="mobile-backdrop"></div>

    <div id="app">
        <button id="btn-brightness-toggle">‚òÄÔ∏è Full Bright: OFF</button>
        <!-- Left Sidebar: Assets & Tools -->
        <div class="panel">
            <h2>Card Creator</h2>



            <div class="control-group">
                <h3>Content Tools</h3>
                <button id="btn-add-text">Add Text</button>
                <div style="display:flex; gap:5px;">
                    <button id="btn-add-shape" style="flex:1;">Add Shapes</button>
                    <button id="btn-add-sticker" style="flex:1;">Add Stickers</button>
                </div>
                <button id="btn-import-scan">Import Scanned Card</button>
                <button id="btn-camera-scan" class="hidden">üì∑ Scan with Camera</button>
            </div>

            <style>
                /* Camera Modal */
                #modal-camera {
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: #000;
                    z-index: 6000;
                    display: flex;
                    flex-direction: column;
                }

                #camera-feed {
                    flex-grow: 1;
                    width: 100%;
                    height: 100%;
                    object-fit: cover;
                }

                #camera-overlay {
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }

                #camera-guide {
                    border: 2px solid var(--accent-color);
                    box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5);
                    /* Dim outside */
                    width: 90%;
                    /* In portrait lock, we use inverted aspect ratio (0.77 instead of 1.29) 
                       so the box is tall on screen -> wide physically when rotated */
                    aspect-ratio: 0.772;
                    /* 8.5 / 11 */
                    border-radius: 8px;
                    position: relative;
                }

                #camera-guide::after {
                    content: "Align card here";
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    /* Rotate text 90deg so it looks upright when phone is held landscape (Top-Left) */
                    transform: translate(-50%, -50%) rotate(90deg);
                    color: rgba(255, 255, 255, 0.5);
                    font-size: 1.2rem;
                    white-space: nowrap;
                }

                .camera-controls {
                    position: absolute;
                    bottom: 30px;
                    left: 0;
                    width: 100%;
                    display: flex;
                    justify-content: center;
                    gap: 20px;
                    align-items: center;
                    z-index: 10;
                    padding: 10px;
                    box-sizing: border-box;
                }

                .cam-btn {
                    background: rgba(255, 255, 255, 0.2);
                    border: 2px solid white;
                    color: white;
                    width: 60px;
                    height: 60px;
                    border-radius: 50%;
                    cursor: pointer;
                    font-size: 1.5rem;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }

                .cam-btn.capture {
                    width: 80px;
                    height: 80px;
                    background: white;
                    border: 4px solid rgba(0, 0, 0, 0.2);
                }

                .cam-btn.capture:active {
                    transform: scale(0.95);
                }

                #camera-preview {
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: #111;
                    z-index: 20;
                    display: none;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                }

                #preview-img {
                    max-width: 90%;
                    max-height: 80%;
                    border: 2px solid #555;
                }

                .preview-controls {
                    margin-top: 20px;
                    display: flex;
                    gap: 20px;
                }
            </style>





            <div class="control-group">
                <h3>Cards</h3>
                <button id="btn-new-card" style="margin-bottom: 5px;">+ New Card</button>
                <button id="btn-save-project">Save Card</button>
                <button id="btn-load-project">Load Card</button>
                <button id="btn-preview-card" style="background:#4caf50; color:white;">Preview in Browser</button>
                <button id="btn-export-html" class="primary">Download Card</button>
            </div>

            <div class="control-group">
                <h3>Cloud Tools</h3>
                <!-- Auth Status -->
                <div
                    style="margin-bottom: 10px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 6px;">
                    <div id="auth-status" style="font-size: 0.8rem; margin-bottom: 5px; color: #ccc;">Checking...</div>
                    <button id="btn-login-toggle" style="width: 100%; font-size: 0.8rem; padding: 5px;">Sign In</button>
                </div>

                <button id="btn-shared-cards" class="primary">Shared Cards</button>
                <button id="btn-publish-cloud" class="primary" style="background: #e91e63;">‚òÅÔ∏è Publish to
                    Cloud</button>
            </div>
        </div>

        <!-- Main Viewport -->
        <div id="viewport">
            <canvas id="three-canvas"></canvas>



            <!-- View Controls (Focus Modes) -->
            <div class="view-controls">
                <button class="view-btn active" data-view="orbit">Free View</button>
                <button class="view-btn" data-view="front">Front</button>
                <button class="view-btn" data-view="inside-left">Inside Left</button>
                <button class="view-btn" data-view="inside-right">Inside Right</button>
                <button class="view-btn" data-view="back">Back</button>
            </div>
        </div>

        <!-- Right Sidebar: Properties (Visible on Selection) -->
        <div class="panel panel-right" id="prop-panel" style="transform: translateX(110%);">
            <h2>Properties</h2>
            <div id="props-content">
                <!-- Dynamic Properties -->
            </div>
            <button id="btn-clone-element" style="background: var(--accent-color); margin-top: 20px;">Clone
                Element</button>
            <button id="btn-delete-element" style="background: #a33; margin-top: 10px;">Delete Element</button>
            <button id="btn-close-props" style="margin-top: 10px;">Close</button>
        </div>
    </div>
    </div>



    <!-- Hidden inputs/canvases -->
    <input type="file" id="file-input-scan-front" accept="image/*">
    <input type="file" id="file-input-scan-back" accept="image/*">
    <div class="offscreen-canvas-container">
        <canvas id="tex-canvas-outside" width="2048" height="1582"></canvas>
        <canvas id="tex-canvas-inside" width="2048" height="1582"></canvas>
    </div>

    <!-- Error Handler -->
    <script>
        setTimeout(() => {
            if (!window.THREE && !document.querySelector('canvas').clientHeight) {
                document.getElementById('loading-msg').innerHTML =
                    "Could not load Three.js.<br>Please check your internet connection and reload.<br>This app requires an internet connection for the first run to cache libraries.";
                document.getElementById('loading-msg').style.color = "#ff6b6b";
            }
        }, 5000);
    </script>

    <script type="module">
        import awsconfig from './aws-exports.js';
        import { Amplify } from 'aws-amplify';
        import { uploadData, list, remove, getUrl } from 'aws-amplify/storage';
        import { getCurrentUser, fetchAuthSession, signIn, signUp, confirmSignUp, autoSignIn, signOut, fetchUserAttributes } from 'aws-amplify/auth';
        import { Hub } from 'aws-amplify/utils';
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        console.log("Configuring Amplify with (flat):", awsconfig);

        try {
            Amplify.configure({
                Auth: {
                    Cognito: {
                        userPoolId: awsconfig.aws_user_pools_id,
                        userPoolClientId: awsconfig.aws_user_pools_web_client_id,
                        identityPoolId: awsconfig.aws_cognito_identity_pool_id,
                        allowGuestAccess: true,
                        // Explicitly set the region for credential verification
                        region: awsconfig.aws_cognito_region,
                        loginWith: {
                            email: true
                        }
                    }
                },
                Storage: {
                    S3: {
                        bucket: awsconfig.aws_user_files_s3_bucket,
                        region: awsconfig.aws_user_files_s3_bucket_region
                    }
                }
            });
            console.log("Amplify v6 configuration successful");
        } catch (e) {
            console.error("Amplify configuration failed:", e);
        }

        // Hide loader
        const loader = document.getElementById('loading-overlay');
        if (loader) {
            console.log("Hiding loader...");
            loader.style.display = 'none';
            loader.classList.add('hidden');
        } else {
            console.error("Loader NOT found!");
        }

        // --- State Management ---
        const STATE = {
            cardOpen: 0.5, // 0 to 1
            viewMode: 'orbit', // orbit, front, inside-left, inside-right, back
            selectedElement: null,
            selectedPanel: null, // 'front', 'back', 'inside-left', 'inside-right'
            db: null, // IndexedDB
            fullBright: false,

            // Canvas Data Models
            // Each item: { id, type: 'text'|'image'|'shape', x, y, width, height, rotation, ...props }
            layers: {
                outside: [],
                inside: []
            },

            assets: [] // Loaded images blobs
        };

        /** 
         * Constants
         * Standard Letter: 11in x 8.5in
         * Folded: 5.5in x 8.5in
         * 3D Units: 1 unit = 1 inch
         */
        const DIMS = {
            width: 11,
            height: 8.5,
            panelWidth: 5.5
        };

        // --- 3D Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);

        // Camera
        // Camera
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);



        camera.position.set(0, 10, 15);

        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-canvas'), antialias: true, alpha: true });

        function updateRendererSize() {
            const container = document.getElementById('viewport');
            const w = container.offsetWidth;
            const h = container.offsetHeight;
            renderer.setSize(w, h);
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
            return { w, h };
        }
        // Initial sizing
        const container = document.getElementById('viewport');
        renderer.setSize(container.offsetWidth, container.offsetHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Lights
        const ambLight = new THREE.AmbientLight(0xffffff, 1.5); // Very High base brightness
        scene.add(ambLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.6); // Subtle gradients
        dirLight.position.set(5, 10, 7);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // Global Error Handler for user feedback
        window.onerror = function (msg, url, line) {
            console.error(msg);
            showCustomAlert("System Error: " + msg, "Error");
        };

        // --- Card Geometry Setup ---
        // Reformulated for Standard English Opening (Hinge on Left, Front Cover opens L->R).
        // Left Wing = Front Cover + Inside Left.
        // Right Wing = Back Cover + Inside Right.

        const PAPER_THICKNESS = 0.01;
        const P_WIDTH = DIMS.panelWidth; // 5.5
        const P_HEIGHT = DIMS.height;    // 8.5
        const P_CENTER_OFFSET = P_WIDTH / 2; // 2.75

        // Materials (Canvas Textures)
        const canvasOutside = document.getElementById('tex-canvas-outside');
        const canvasInside = document.getElementById('tex-canvas-inside');

        const texOutside = new THREE.CanvasTexture(canvasOutside);
        texOutside.colorSpace = THREE.SRGBColorSpace;
        const texInside = new THREE.CanvasTexture(canvasInside);
        texInside.colorSpace = THREE.SRGBColorSpace;

        // Expose for debug/Canvas2D access
        window.texOutside = texOutside;
        window.texInside = texInside;

        // Use Basic Material with DoubleSide to ensure visibility and Raycast hits
        // Use Standard Material for reacting to lights
        const matOutside = new THREE.MeshStandardMaterial({
            map: texOutside, side: THREE.DoubleSide, roughness: 0.6, metalness: 0.0
        });
        const matInside = new THREE.MeshStandardMaterial({
            map: texInside, side: THREE.DoubleSide, roughness: 0.6, metalness: 0.0
        });

        // Groups
        const mainCardGroup = new THREE.Group();
        scene.add(mainCardGroup);

        const leftWing = new THREE.Group();
        const rightWing = new THREE.Group();

        // Offset Left Wing (Front) forward to fold ON TOP of Right Wing (Back)
        leftWing.position.z = PAPER_THICKNESS * 2;

        mainCardGroup.add(leftWing);
        mainCardGroup.add(rightWing);

        // Standard Centered Plane
        const geoBase = new THREE.PlaneGeometry(P_WIDTH, P_HEIGHT);

        // --- Left Wing (Front Cover + Inside Left) ---
        // Pivot at 0. Panel extends -X.

        const leftInsideMesh = new THREE.Mesh(geoBase.clone(), matInside);
        leftInsideMesh.position.set(-P_CENTER_OFFSET, 0, PAPER_THICKNESS);
        setUVs(leftInsideMesh.geometry, 0, 0.5); // Inside Left

        const leftOutsideMesh = new THREE.Mesh(geoBase.clone(), matOutside);
        leftOutsideMesh.position.set(-P_CENTER_OFFSET, 0, -PAPER_THICKNESS);
        leftOutsideMesh.rotation.y = Math.PI;
        // FRONT COVER (Canvas 0.5-1.0).
        // Rot 180. Local Left(-X) is World Right(Spine).
        // Map U0(Edge) -> 1.0. U1(Spine) -> 0.5.
        setUVs(leftOutsideMesh.geometry, 0.5, 1.0); // Fixed Front UVs

        leftWing.add(leftInsideMesh);
        leftWing.add(leftOutsideMesh);

        // --- Right Wing (Back Cover + Inside Right) ---
        // Pivot at 0. Panel extends +X. Stationary.

        const rightInsideMesh = new THREE.Mesh(geoBase.clone(), matInside);
        rightInsideMesh.position.set(P_CENTER_OFFSET, 0, PAPER_THICKNESS);
        setUVs(rightInsideMesh.geometry, 0.5, 1.0); // Inside Right

        const rightOutsideMesh = new THREE.Mesh(geoBase.clone(), matOutside);
        rightOutsideMesh.position.set(P_CENTER_OFFSET, 0, -PAPER_THICKNESS);
        rightOutsideMesh.rotation.y = Math.PI;
        // BACK COVER (Canvas 0.0-0.5).
        // Rot 180. Local Left(-X) is World Right(Edge).
        // Map U0(Spine) -> 0.5. U1(Edge) -> 0.0.
        setUVs(rightOutsideMesh.geometry, 0.0, 0.5); // Fixed Back UVs

        rightWing.add(rightInsideMesh);
        rightWing.add(rightOutsideMesh);


        // --- Helper: UV Mapping ---
        function setUVs(geometry, uMin, uMax) {
            const uvs = geometry.attributes.uv;
            for (let i = 0; i < uvs.count; i++) {
                const u = uvs.getX(i);
                const newU = uMin + u * (uMax - uMin);
                uvs.setX(i, newU);
            }
            uvs.needsUpdate = true;
        }

        // --- Animation & View Logic ---

        // Define targets. 
        // Angle: 0 -> -PI (Right wing folds Over) -> Now Left Wing folds +PI
        const viewPositions = {
            'orbit': { pos: null, look: null },
            'front': {
                pos: new THREE.Vector3(P_CENTER_OFFSET, 0, 15), // Looking at Closed Front (+X)
                look: new THREE.Vector3(P_CENTER_OFFSET, 0, 0)
            },
            'back': {
                pos: new THREE.Vector3(-P_CENTER_OFFSET, 0, 15), // Same X as inside-left, Front Z
                look: new THREE.Vector3(-P_CENTER_OFFSET, 0, 0)
            },
            'inside-left': {
                pos: new THREE.Vector3(-P_CENTER_OFFSET, 0, 15),
                look: new THREE.Vector3(-P_CENTER_OFFSET, 0, 0)
            },
            'inside-right': {
                pos: new THREE.Vector3(P_CENTER_OFFSET, 0, 15),
                look: new THREE.Vector3(P_CENTER_OFFSET, 0, 0)
            }
        };

        function updateFold(openFactor) {
            // openFactor: 1.0 (Flat Open) -> 0.0 (Closed)
            // Left Wing rotates 0 -> +PI.

            const angle = (1 - openFactor) * Math.PI;
            // Limit slightly to prevent mesh collision if logic fails
            const clampAngle = Math.min(angle, Math.PI - 0.05);

            leftWing.rotation.y = clampAngle;
            STATE.cardOpen = openFactor;

            // Auto-Fit Camera if in Orbit mode (User Interaction)
            if (STATE.viewMode === 'orbit') {
                updateCameraFit(angle);
            }
        }

        function updateCameraFit(angle) {
            // Ensure world matrices are updated for accurate bounds
            mainCardGroup.updateWorldMatrix(true, true);

            const box = new THREE.Box3().setFromObject(mainCardGroup);

            // If box is empty/invalid (e.g. first run), fallback
            if (box.isEmpty()) return;

            const size = new THREE.Vector3();
            box.getSize(size);
            const center = new THREE.Vector3();
            box.getCenter(center);

            // Constraint: Never treat the content as smaller than a folded card (5.5 x 8.5)
            // This prevents excessive zooming when viewing the card edge-on.
            const width = Math.max(size.x, 5.5);
            const height = Math.max(size.y, 8.5);

            const sphere = new THREE.Sphere();
            box.getBoundingSphere(sphere);

            // Recalc Safe Z
            const aspect = camera.aspect;
            const vFov = camera.fov * (Math.PI / 180);

            // Add Padding
            const PAD_H = 1.05;
            const PAD_W = 1.05;

            const fitH = (height * PAD_H) / Math.tan(vFov / 2);
            const fitW = (width * PAD_W) / (Math.tan(vFov / 2) * aspect);

            // Use Sphere Radius to guarantee a safe minimum distance regardless of rotation
            const sphereDist = (sphere.radius * 1.05) / Math.sin(vFov / 2);

            // Min distance floor to prevent extreme zooming
            // We can relax the hard floor since the width/height constraint handles the geometry case
            const bestZ = Math.max(5, fitH, fitW, sphereDist) * 0.7;

            // Smoothly move Camera (Pan + Zoom)
            const targetPos = new THREE.Vector3(center.x, center.y, 0); // Keep Y center relative to card vertically? Usually card is at Y=0. center.y should be 0. Let's trust the box center.

            // For simple "Flat Front" Logic (default orbit):
            // Camera X should align with Center X.
            // Camera Z should be bestZ.

            // However, if user tilted the camera (Orbit), we want to preserve direction?
            // User Request: "camera to pan over and zoom in".
            // Implementation: We'll modify target and set distance.

            // Get current direction vector
            const offset = camera.position.clone().sub(controls.target);
            const currentDist = offset.length();
            const dir = offset.normalize();

            // New Target
            controls.target.copy(targetPos);

            // New Position: Target + Dir * bestZ ? 
            // bestZ is "Distance to plane" roughly.
            // If we are looking top-down, Z is height.
            // Let's just use bestZ as the distance modulus for simplicity, 
            // or projection if aligned. 
            // Since standard view is Z-aligned:

            // If the camera is roughly looking down Z:
            if (Math.abs(dir.z) > 0.5) {
                // Adjust scaling to ensure Z-depth matches bestZ
                // NewDist such that the Z-component equals bestZ?
                // No, bestZ is the required distance from the plane.
                camera.position.copy(targetPos).add(dir.multiplyScalar(bestZ));
            } else {
                // Side view? Just Pan.
                camera.position.copy(targetPos).add(offset); // Pan only
            }

            controls.update();
        }



        // --- Canvas Drawing Logic ---
        const Canvas2D = {
            ctxOut: canvasOutside.getContext('2d'),
            ctxIn: canvasInside.getContext('2d'),
            width: 2048,
            height: 1582,

            // Redraw entire canvas from state
            render: function () {
                console.log("Canvas2D: Rendering...");
                try {
                    this.clear(this.ctxOut);
                    this.clear(this.ctxIn);

                    // Draw backgrounds (White paper)
                    this.ctxOut.fillStyle = '#ffffff';
                    this.ctxOut.fillRect(0, 0, this.width, this.height);

                    this.ctxIn.fillStyle = '#ffffff';
                    this.ctxIn.fillRect(0, 0, this.width, this.height);

                    // Draw guide link (fold)
                    this.drawGuide(this.ctxOut);
                    this.drawGuide(this.ctxIn);

                    // Render Layers
                    if (STATE.layers) {
                        STATE.layers.outside.forEach(l => this.drawLayer(this.ctxOut, l));
                        STATE.layers.inside.forEach(l => this.drawLayer(this.ctxIn, l));
                    }

                    // Update Textures
                    if (window.texOutside) texOutside.needsUpdate = true;
                    if (window.texInside) texInside.needsUpdate = true;

                } catch (e) {
                    console.error("Canvas Render Error", e);
                    alert("Canvas Render Error: " + e.message);
                }
            },

            clear: function (ctx) {
                ctx.clearRect(0, 0, this.width, this.height);
            },

            drawGuide: function (ctx) {
                ctx.strokeStyle = '#eee';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.width / 2, 0);
                ctx.lineTo(this.width / 2, this.height);
                ctx.stroke();
            },
        };

        // --- Interaction State ---
        let interactionState = {
            mode: 'none', // 'none', 'drag', 'resize', 'rotate'
            handle: null, // 'tl', 'tr', 'bl', 'br', 'rot'
            startPos: { x: 0, y: 0 },
            startElemParams: null
        };

        const HANDLES = {
            tl: { x: -1, y: -1, cursor: 'nw-resize' },
            tr: { x: 1, y: -1, cursor: 'ne-resize' },
            bl: { x: -1, y: 1, cursor: 'sw-resize' },
            br: { x: 1, y: 1, cursor: 'se-resize' },
            rot: { x: 0, y: -1, offset: 40, cursor: 'grab' } // Top stick
        };
        const HANDLE_SIZE = 12;

        Canvas2D.drawLayer = function (ctx, layer) {
            ctx.save();
            ctx.translate(layer.x, layer.y);
            ctx.rotate(layer.rotation || 0);

            // Draw content
            if (layer.type === 'text') {
                ctx.font = `${layer.bold ? 'bold ' : ''}${layer.fontSize}px ${layer.fontFamily}`;
                ctx.fillStyle = layer.color;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(layer.text, 0, 0);
            } else if (layer.type === 'image') {
                if (layer.imgElement) {
                    ctx.drawImage(layer.imgElement, -layer.width / 2, -layer.height / 2, layer.width, layer.height);
                }
            } else if (layer.type === 'shape') {
                ctx.fillStyle = layer.color;
                // Shape drawing logic same as before...
                drawShape(ctx, layer);
            }

            // Draw UI Handles if selected and not locked
            if (layer === STATE.selectedElement) {
                const w = layer.width;
                const h = layer.height;
                const hw = w / 2;
                const hh = h / 2;

                ctx.strokeStyle = '#646cff';
                ctx.lineWidth = 2;
                ctx.strokeRect(-hw, -hh, w, h);

                if (!layer.locked) {
                    ctx.fillStyle = '#fff';
                    ctx.strokeStyle = '#646cff';
                    ctx.lineWidth = 1;

                    // Corners
                    [[-hw, -hh], [hw, -hh], [-hw, hh], [hw, hh]].forEach(([x, y]) => {
                        ctx.beginPath();
                        ctx.arc(x, y, HANDLE_SIZE / 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    });

                    // Rotation Stick
                    ctx.beginPath();
                    ctx.moveTo(0, -hh);
                    ctx.lineTo(0, -hh - 30);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(0, -hh - 30, HANDLE_SIZE / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                }
            }
            ctx.restore();
        };

        // Helper to share shape logic
        function drawShape(ctx, layer) {
            ctx.beginPath();
            const w = layer.width; const h = layer.height;
            const hw = w / 2; const hh = h / 2;
            if (layer.subtype === 'rect') { ctx.fillRect(-hw, -hh, w, h); }
            else if (layer.subtype === 'circle') { ctx.ellipse(0, 0, Math.abs(hw), Math.abs(hh), 0, 0, Math.PI * 2); ctx.fill(); }
            else if (layer.subtype === 'triangle') {
                ctx.moveTo(0, -hh); ctx.lineTo(hw, hh); ctx.lineTo(-hw, hh);
                ctx.closePath(); ctx.fill();
            } else if (layer.subtype === 'star') {
                // ... original star logic ...
                const outer = Math.min(w, h) / 2; const inner = outer * 0.4;
                for (let i = 0; i < 10; i++) {
                    const r = (i % 2 === 0) ? outer : inner;
                    const ang = -Math.PI / 2 + i * (Math.PI / 5);
                    const x = Math.cos(ang) * r; const y = Math.sin(ang) * r;
                    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                }
                ctx.closePath(); ctx.fill();
            } else if (layer.subtype === 'heart') {
                const topCurveHeight = h * 0.3;
                ctx.moveTo(0, -hh + topCurveHeight);
                ctx.bezierCurveTo(-w / 2, -hh, -w, -hh + topCurveHeight, 0, hh);
                ctx.bezierCurveTo(w, -hh + topCurveHeight, w / 2, -hh, 0, -hh + topCurveHeight);
                ctx.fill();
            }
        }

        // --- Interaction Variables ---
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();

        function getCanvasCoords(hit) {
            const uv = hit.uv;
            let cx = uv.x * Canvas2D.width;
            const cy = (1 - uv.y) * Canvas2D.height;
            // No offset needed
            return { x: cx, y: cy };
        }

        // Interaction
        function onPointerDown(event) {
            if (event.target !== renderer.domElement) return;
            if (STATE.viewMode === 'orbit') return;

            // Recalc pointer for canvas
            const rect = renderer.domElement.getBoundingClientRect();
            pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            pointer.y = - ((event.clientY - rect.top) / rect.height) * 2 + 1;

            if (STATE.selectedElement && !STATE.selectedElement.locked) {
                // Check Handles first
                // Use Raycaster to find where we clicked on the canvas relative to element?
                // Easier: Map mouse click to canvas coords, then transform to element local space.

                raycaster.setFromCamera(pointer, camera);
                const isFrontBack = (STATE.viewMode === 'front' || STATE.viewMode === 'back');
                const meshes = isFrontBack ? [leftOutsideMesh, rightOutsideMesh] : [leftInsideMesh, rightInsideMesh];
                const intersects = raycaster.intersectObjects(meshes);

                if (intersects.length > 0) {
                    const clickPos = getCanvasCoords(intersects[0]);
                    const el = STATE.selectedElement;

                    // To Local Space
                    const dx = clickPos.x - el.x;
                    const dy = clickPos.y - el.y;
                    // Un-rotate
                    const theta = -(el.rotation || 0);
                    const lx = dx * Math.cos(theta) - dy * Math.sin(theta);
                    const ly = dx * Math.sin(theta) + dy * Math.cos(theta);

                    const hw = el.width / 2;
                    const hh = el.height / 2;
                    const PAD = HANDLE_SIZE;

                    // Check Handles
                    if (Math.abs(lx - (-hw)) < PAD && Math.abs(ly - (-hh)) < PAD) return startResize('tl', clickPos);
                    if (Math.abs(lx - (hw)) < PAD && Math.abs(ly - (-hh)) < PAD) return startResize('tr', clickPos);
                    if (Math.abs(lx - (-hw)) < PAD && Math.abs(ly - (hh)) < PAD) return startResize('bl', clickPos);
                    if (Math.abs(lx - (hw)) < PAD && Math.abs(ly - (hh)) < PAD) return startResize('br', clickPos);
                    if (Math.abs(lx - 0) < PAD && Math.abs(ly - (-hh - 30)) < PAD) return startRotate(clickPos);
                }
            }

            // Normal Hit Detection (Drag/Select)
            raycaster.setFromCamera(pointer, camera);
            const isFrontBack = (STATE.viewMode === 'front' || STATE.viewMode === 'back');
            const targets = isFrontBack ? [leftOutsideMesh, rightOutsideMesh] : [leftInsideMesh, rightInsideMesh];
            const intersects = raycaster.intersectObjects(targets);

            if (intersects.length > 0) {
                const hit = intersects[0];
                const pos = getCanvasCoords(hit);
                const cx = pos.x; const cy = pos.y;
                const isInside = (hit.object === leftInsideMesh || hit.object === rightInsideMesh);
                const list = isInside ? STATE.layers.inside : STATE.layers.outside;

                let found = null;
                for (let i = list.length - 1; i >= 0; i--) {
                    const el = list[i];
                    // Simple box check (rotation aware would be better, but AABB is standard for simple hit test)
                    // We'll use simple distance/box for now for selection.
                    const padding = 25;
                    const distCheck = Math.abs(cx - el.x) < (el.width / 2 + padding) && Math.abs(cy - el.y) < (el.height / 2 + padding);
                    // Could check rotation if needed, but this is usually fine for selection.
                    if (distCheck) { found = el; break; }
                }

                if (found) {
                    STATE.selectedElement = found;
                    interactionState = { mode: 'drag', startPos: pos, startElemParams: { ...found } };
                    controls.enabled = false;
                    showProperties(found);
                    Canvas2D.render();
                } else {
                    STATE.selectedElement = null;
                    document.getElementById('prop-panel').style.transform = 'translateX(110%)';
                    Canvas2D.render();
                }
            }
        }

        function startResize(handle, pos) {
            interactionState = {
                mode: 'resize',
                handle: handle,
                startPos: pos,
                startElemParams: JSON.parse(JSON.stringify(STATE.selectedElement))
            };
            controls.enabled = false;
        }

        function startRotate(pos) {
            interactionState = {
                mode: 'rotate',
                handle: 'rot',
                startPos: pos,
                startElemParams: JSON.parse(JSON.stringify(STATE.selectedElement))
            };
            controls.enabled = false;
        }

        function onPointerMove(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            pointer.y = - ((event.clientY - rect.top) / rect.height) * 2 + 1;

            // Handle Interactions
            if (interactionState.mode !== 'none' && STATE.viewMode !== 'orbit' && STATE.selectedElement) {
                // Raycast to get current Canvas Pos
                raycaster.setFromCamera(pointer, camera);
                const isFrontBack = (STATE.viewMode === 'front' || STATE.viewMode === 'back');
                const meshes = isFrontBack ? [leftOutsideMesh, rightOutsideMesh] : [leftInsideMesh, rightInsideMesh];
                const intersects = raycaster.intersectObjects(meshes);

                if (intersects.length > 0) {
                    const currPos = getCanvasCoords(intersects[0]);
                    const el = STATE.selectedElement;
                    const start = interactionState.startElemParams;

                    if (interactionState.mode === 'drag' && !el.locked) {
                        el.x = start.x + (currPos.x - interactionState.startPos.x);
                        el.y = start.y + (currPos.y - interactionState.startPos.y);
                    } else if (interactionState.mode === 'rotate') {
                        // Angle from center to current mouse
                        const dx = currPos.x - el.x;
                        const dy = currPos.y - el.y;
                        let angle = Math.atan2(dy, dx);
                        // Offset by -PI/2 because handle is at top (-90deg)
                        angle += Math.PI / 2;
                        el.rotation = angle;
                    } else if (interactionState.mode === 'resize') {
                        // Standard Corner Resizing
                        // We need to respect rotation.
                        // Calculate delta in local space? Or simple distance scaling?
                        // Simple distance-from-center scaling is easiest and robust for rotated objects.
                        const startDist = Math.hypot(interactionState.startPos.x - start.x, interactionState.startPos.y - start.y);
                        const currDist = Math.hypot(currPos.x - start.x, currPos.y - start.y);
                        const scale = currDist / startDist;

                        // Apply scale
                        let newW = start.width * scale;
                        let newH = start.height * scale;

                        // Lock Ratio (Default true)
                        if (el.ratioLocked !== false) {
                            // Scale matches
                        } else {
                            // Free scaling requires vector projection logic (complex).
                            // For this iteration, let's just do uniform scaling if locked, 
                            // or maybe just keep it uniform for corners always?
                            // User asked for "option to lock ratio".
                            // If unlocked, we usually need handle-specific logic. 
                            // Let's implement uniform scaling for now as it's 90% of use cases.
                            // If unlocked, we can just allow W/H changes but it's tricky with rotation.
                            // Let's stick to uniform scaling for Corner Handles for now
                            // OR simplify: assume uniform scaling for corners for MVP.
                        }

                        el.width = newW;
                        el.height = newH;

                        // Font scaling check
                        if (el.type === 'text') {
                            el.fontSize = start.fontSize * scale;
                        }
                    }
                    Canvas2D.render();
                    return;
                }
            }
        }

        function onPointerUp() {
            interactionState.mode = 'none';
            if (STATE.viewMode === 'orbit') controls.enabled = true;
        }

        window.addEventListener('pointermove', onPointerMove);
        window.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('pointerup', onPointerUp);
        window.addEventListener('resize', onWindowResize);

        function onWindowResize() {
            const { w, h } = updateRendererSize();

            // Determine context for resize
            let wFit = 11.0;
            if (STATE.viewMode === 'front' || STATE.viewMode === 'back') wFit = 5.5;

            const safeZ = getSafeZ(wFit);
            const sign = (camera.position.z >= 0) ? 1 : -1;

            // Recalc existing Camera Fit if in orbit mode
            if (STATE.viewMode === 'orbit') {
                const angle = (1 - STATE.cardOpen) * Math.PI;
                updateCameraFit(angle);
            } else {
                // If we are locked in a view, force recenter
                const targetPos = camera.position.clone();
                targetPos.z = safeZ * sign;

                // If on mobile, auto-center X too in case of drift
                const targetLook = controls.target.clone();
                targetLook.x = 0;
                targetLook.y = 0;

                animateCamera(targetPos, targetLook);
            }
        }

        function getSafeZ(targetWidth = 11.0) {
            const container = document.getElementById('viewport');
            const aspect = container.offsetWidth / container.offsetHeight;
            const vFov = camera.fov * (Math.PI / 180);

            // Height fit: Card is 8.5 high. Let's provide some padding (1.05x).
            // Width fit: Card is targetWidth wide. Let's provide padding (1.05x).

            const heightFit = (8.5 * 1.05) / Math.tan(vFov / 2);
            const widthFit = (targetWidth * 1.05) / (Math.tan(vFov / 2) * aspect);

            // Lower min distance to 5 for closer mobile views
            // Multiplier 0.65 brings it much closer, "zooming out less"
            return Math.max(5, heightFit, widthFit) * 0.65;
        }

        // --- View Modes ---
        let cardYTarget = 0; // Target Y rotation for mainCardGroup

        // Global Animation Loop for smooth transitions
        function animateMain() {
            requestAnimationFrame(animateMain);

            // Smooth Card Y Rotation (Front/Back Switching)
            mainCardGroup.rotation.y += (cardYTarget - mainCardGroup.rotation.y) * 0.1;

            controls.update();
            renderer.render(scene, camera);
        }
        animateMain();

        // viewPositions is defined above in the geometry section

        document.querySelectorAll('.view-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const mode = btn.dataset.view;
                setMode(mode);
            });
        });

        function updateContentToolsState(mode) {
            // We now keep all tools enabled.
            // If clicked in orbit mode, they auto-switch to front view.
            const ids = ['btn-add-text', 'btn-add-shape', 'btn-add-sticker', 'btn-import-scan', 'btn-camera-scan'];
            ids.forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.disabled = false;
                    el.style.opacity = '1';
                    el.style.pointerEvents = 'auto';
                    el.style.cursor = 'pointer';
                }
            });
        }

        function setMode(mode) {
            STATE.viewMode = mode;
            document.querySelectorAll('.view-btn').forEach(b => {
                if (b.dataset.view) b.classList.remove('active');
            });
            const activeBtn = document.querySelector(`.view-btn[data-view="${mode}"]`);
            if (activeBtn) activeBtn.classList.add('active');

            updateContentToolsState(mode);

            if (mode === 'orbit') {
                controls.enabled = true;
                // Open card slightly (20%) for free view
                gsapLikeFold(0.2);

                // Tween camera back to default
                // Note: updateCameraFit uses STATE.cardOpen, which will animate over time.
                // We might settle on final angle instantly for camera fitting or let it update?
                // updateCameraFit calculates distance based on angle. 
                // Let's just fit for the TARGET open state (0.2 -> ~144 deg).
                const targetAngle = (1 - 0.2) * Math.PI;
                updateCameraFit(targetAngle);
                return;
            }

            controls.enabled = false;

            // Auto-open/close card based on view
            if (mode === 'front') {
                gsapLikeFold(0);
                cardYTarget = 0;
            } else if (mode === 'back') {
                gsapLikeFold(0);
                cardYTarget = Math.PI; // Rotate card 180
            } else {
                gsapLikeFold(1);
                cardYTarget = 0;
            }

            const t = viewPositions[mode];
            if (t) {
                // For Back view, we now rotate the card, so we KEEP the camera at +Z
                // viewPositions['back'] previously had -15. We essentially treat it like Front now regarding camera position.

                let targetPos = t.pos.clone();
                // Override removed: 'back' view now defined correctly in viewPositions


                // Determine target width logic
                // If Front (0) or Back (Math.PI/180), we show a single panel (5.5)
                // If Inside, we show full spread (11)

                // Determine target width logic
                // If Front (0) or Back (Math.PI/180), we show a single panel (5.5)
                // If Inside Left/Right, we also want closer zoom on that specific panel (5.5)

                let targetWidth = 11.0;
                if (mode === 'front' || mode === 'back' || mode === 'inside-left' || mode === 'inside-right') {
                    targetWidth = 5.5;
                }

                const safeZ = getSafeZ(targetWidth);
                // Ensure positive Z since we rotate the card
                const sign = 1;
                targetPos.z = safeZ * sign;

                animateCamera(targetPos, t.look);
            }
        }

        function animateCamera(targetPos, targetLook) {
            const startPos = camera.position.clone();
            const startLook = controls.target.clone();

            let t = 0;
            const duration = 1000; // ms
            const start = performance.now();

            function tick(now) {
                const elapsed = now - start;
                t = Math.min(elapsed / duration, 1);
                // EaseInOutQuad
                const ease = t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;

                camera.position.lerpVectors(startPos, targetPos, ease);
                controls.target.lerpVectors(startLook, targetLook, ease);
                // controls.update(); // handled in global loop now

                if (t < 1) requestAnimationFrame(tick);
            }
            requestAnimationFrame(tick);
        }

        function gsapLikeFold(targetVal) {
            const startVal = STATE.cardOpen;
            let t = 0;
            const duration = 800;
            const start = performance.now();

            function tick(now) {
                const elapsed = now - start;
                t = Math.min(elapsed / duration, 1);
                const ease = t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;

                const val = startVal + (targetVal - startVal) * ease;
                updateFold(val);
                // No slider to update anymore

                if (t < 1) requestAnimationFrame(tick);
            }
            requestAnimationFrame(tick);
        }

        // --- Tool Logic ---
        function addText() {
            // Auto-switch to Front view if in Orbit, to make it easier for user
            if (STATE.viewMode === 'orbit') {
                setMode('front');
            }

            // Allow transition time if we just switched
            setTimeout(() => {
                const isInside = STATE.viewMode.includes('inside');
                const list = isInside ? STATE.layers.inside : STATE.layers.outside;

                // Determine center based on current view
                let x = isInside ? (STATE.viewMode === 'inside-right' ? Canvas2D.width * 0.75 : Canvas2D.width * 0.25)
                    : (STATE.viewMode === 'front' ? Canvas2D.width * 0.75 : Canvas2D.width * 0.25);

                const newItem = {
                    id: Date.now(),
                    type: 'text',
                    text: 'New Text',
                    x: x,
                    y: Canvas2D.height / 2,
                    fontSize: 60,
                    fontFamily: 'Inter',
                    color: '#000000',
                    bold: false,
                    rotation: 0,
                    width: 0, height: 0,
                    ratioLocked: true
                };

                // Approx dimensions
                const ctx = isInside ? Canvas2D.ctxIn : Canvas2D.ctxOut;
                ctx.font = `${newItem.bold ? 'bold ' : ''}${newItem.fontSize}px ${newItem.fontFamily}`;
                const m = ctx.measureText(newItem.text);
                newItem.width = m.width;
                newItem.height = 60;

                list.push(newItem);
                STATE.selectedElement = newItem;
                Canvas2D.render();
                showProperties(newItem);
            }, 100);
        }

        document.getElementById('btn-add-text').onclick = addText;

        function addRect() {
            if (STATE.viewMode === 'orbit') {
                setMode('front');
            }
            setTimeout(() => {
                const isInside = STATE.viewMode.includes('inside');
                const list = isInside ? STATE.layers.inside : STATE.layers.outside;

                // Determine center
                let x = isInside ? (STATE.viewMode === 'inside-right' ? Canvas2D.width * 0.75 : Canvas2D.width * 0.25)
                    : (STATE.viewMode === 'front' ? Canvas2D.width * 0.75 : Canvas2D.width * 0.25);

                const newItem = {
                    id: Date.now(),
                    type: 'rect',
                    x: x,
                    y: Canvas2D.height / 2,
                    width: 200,
                    height: 100,
                    rotation: 0,
                    color: '#ff0000'
                };

                list.push(newItem);
                STATE.selectedElement = newItem;
                Canvas2D.render();
                showProperties(newItem);
            }, 100);
        }
        // document.getElementById('btn-add-rect').onclick = addRect; // Removed

        // Mobile Toggle Logic
        document.getElementById('btn-toggle-left').addEventListener('click', () => {
            document.querySelector('.panel').classList.toggle('active');
            document.getElementById('mobile-backdrop').classList.toggle('active');
        });

        document.getElementById('btn-toggle-right').addEventListener('click', () => {
            document.getElementById('prop-panel').classList.toggle('active');
            document.getElementById('mobile-backdrop').classList.toggle('active');
        });

        document.getElementById('mobile-backdrop').addEventListener('click', () => {
            document.querySelector('.panel').classList.remove('active');
            document.getElementById('prop-panel').classList.remove('active');
            document.getElementById('mobile-backdrop').classList.remove('active');
        });

        // Brightness Toggle
        document.getElementById('btn-brightness-toggle').onclick = () => {
            STATE.fullBright = !STATE.fullBright;
            const btn = document.getElementById('btn-brightness-toggle');

            if (STATE.fullBright) {
                btn.innerText = "‚òÄÔ∏è Full Bright: ON";
                btn.style.background = "rgba(255, 255, 255, 0.3)";

                // Switch to "Full Bright" look (Emissive Map)
                // Use the texture as emissive map so it glows with its own colors
                matOutside.emissiveMap = matOutside.map;
                matOutside.emissive.setHex(0xffffff);
                matOutside.emissiveIntensity = 1.0;
                matOutside.color.setHex(0x000000); // Disable diffuse lighting
                matOutside.needsUpdate = true;

                matInside.emissiveMap = matInside.map;
                matInside.emissive.setHex(0xffffff);
                matInside.emissiveIntensity = 1.0;
                matInside.color.setHex(0x000000); // Disable diffuse lighting
                matInside.needsUpdate = true;

            } else {
                btn.innerText = "‚òÄÔ∏è Full Bright: OFF";
                btn.style.background = ""; // Reset

                // Revert to "Lit" look
                matOutside.emissiveMap = null;
                matOutside.emissive.setHex(0x000000);
                matOutside.emissiveIntensity = 0.0;
                matOutside.color.setHex(0xffffff); // Restore diffuse
                matOutside.needsUpdate = true;

                matInside.emissiveMap = null;
                matInside.emissive.setHex(0x000000);
                matInside.emissiveIntensity = 0.0;
                matInside.color.setHex(0xffffff); // Restore diffuse
                matInside.needsUpdate = true;
            }
        };

        // --- Shape UI ---
        document.getElementById('btn-add-shape').onclick = () => {
            const modal = document.getElementById('modal-shapes');
            modal.classList.remove('hidden');
        };
        document.getElementById('btn-close-shapes').onclick = () => {
            document.getElementById('modal-shapes').classList.add('hidden');
        };

        document.querySelectorAll('.shape-opt').forEach(btn => {
            btn.onclick = () => {
                const subtype = btn.dataset.shape;
                addShape(subtype);
                document.getElementById('modal-shapes').classList.add('hidden');
            };
        });

        function addShape(subtype) {
            if (STATE.viewMode === 'orbit') setMode('front');
            setTimeout(() => {
                const isInside = STATE.viewMode.includes('inside');
                const list = isInside ? STATE.layers.inside : STATE.layers.outside;
                const x = isInside ? (STATE.viewMode === 'inside-right' ? Canvas2D.width * 0.75 : Canvas2D.width * 0.25)
                    : (STATE.viewMode === 'front' ? Canvas2D.width * 0.75 : Canvas2D.width * 0.25);

                let w = 200, h = 200;
                let color = '#ff0000';
                if (subtype === 'star') color = '#ffd700';
                if (subtype === 'heart') color = '#ff69b4';
                if (subtype === 'triangle') { w = 200; h = 174; }

                const newItem = {
                    id: Date.now(),
                    type: 'shape',
                    subtype: subtype,
                    x: x,
                    y: Canvas2D.height / 2,
                    width: w,
                    height: h,
                    rotation: 0,
                    color: color,
                    ratioLocked: true
                };

                list.push(newItem);
                STATE.selectedElement = newItem;
                Canvas2D.render();
                showProperties(newItem);
            }, 100);
        }


        // --- Sticker UI ---
        document.getElementById('btn-add-sticker').onclick = () => {
            document.getElementById('modal-stickers').classList.remove('hidden');
        };
        document.getElementById('btn-close-stickers').onclick = () => {
            document.getElementById('modal-stickers').classList.add('hidden');
        };

        // Tabs
        const tabGeneral = document.getElementById('tab-general');
        const tabUpload = document.getElementById('tab-upload');
        const contentGeneral = document.getElementById('sticker-content-general');
        const contentUpload = document.getElementById('sticker-content-upload');

        tabGeneral.onclick = () => {
            tabGeneral.classList.add('active'); tabUpload.classList.remove('active');
            contentGeneral.classList.remove('hidden'); contentUpload.classList.add('hidden');
        };
        tabUpload.onclick = () => {
            tabUpload.classList.add('active'); tabGeneral.classList.remove('active');
            contentUpload.classList.remove('hidden'); contentGeneral.classList.add('hidden');
        };

        // Clone Element Logic
        document.getElementById('btn-clone-element').onclick = () => {
            if (!STATE.selectedElement) return;

            const original = STATE.selectedElement;
            const isInside = STATE.layers.inside.includes(original);
            const list = isInside ? STATE.layers.inside : STATE.layers.outside;

            // Deep clone the object
            const clone = JSON.parse(JSON.stringify(original));
            clone.id = Date.now(); // New ID
            clone.x += 40; // Offset slighty so user sees it
            clone.y += 40;

            // If it's an image/sticker, we need to re-assign the imgElement reference
            // or re-load it if it was lost in serialization.
            if (original.type === 'image' && original.imgElement) {
                clone.imgElement = original.imgElement;
            }

            list.push(clone);
            STATE.selectedElement = clone;
            Canvas2D.render();
            showProperties(clone);
            showToast("Element Cloned");
        };

        // Sticker Upload Logic
        document.getElementById('sticker-upload-input').onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (evt) => {
                addStickerImage(evt.target.result);
                document.getElementById('modal-stickers').classList.add('hidden');
            };
            reader.readAsDataURL(file);
        };

        function addStickerImage(src) {
            // Auto-switch to Front view if in Orbit
            if (STATE.viewMode === 'orbit') {
                setMode('front');
            }

            setTimeout(() => {
                const img = new Image();
                img.onload = () => {
                    // Logic to scale down if too big
                    const MAX_SIZE = 500; // 500px is roughly 1/4 of card width 2048
                    let w = img.width;
                    let h = img.height;

                    if (w > MAX_SIZE || h > MAX_SIZE) {
                        const ratio = w / h;
                        if (w > h) {
                            w = MAX_SIZE;
                            h = w / ratio;
                        } else {
                            h = MAX_SIZE;
                            w = h * ratio;
                        }
                    }

                    const vm = STATE.viewMode || 'front';
                    const isInside = vm.includes('inside');
                    const list = isInside ? STATE.layers.inside : STATE.layers.outside;

                    // Center in view based on the CURRENT vm
                    let xPct = 0.75; // Default to Right side (Front / Inside Right)

                    if (vm === 'back' || vm === 'inside-left') {
                        xPct = 0.25; // Left side
                    }

                    const x = Canvas2D.width * xPct;

                    list.push({
                        id: Date.now(),
                        type: 'image',
                        imgElement: img,
                        src: src, // Base64 or URL
                        x: x, y: Canvas2D.height / 2,
                        width: w, height: h,
                        rotation: 0,
                        ratioLocked: true
                    });
                    Canvas2D.render();
                };
                img.src = src;
            }, 100);
        }

        // populate general stickers
        const generalGrid = document.getElementById('sticker-content-general');
        const sheetUrl = 'src/assets/stickers/stickers_1.png';

        // Approximate coordinates for the 10 stickers in the generated sheet (1:2 aspect ratio)
        // Adjust these based on the actual generated image layout.
        // Assuming a 2-row layout or similar based on generation prompt.
        // For a robust system, we would use individual files. 
        // Here we slice the sheet on the fly to Data URIs.

        const FONTS = [
            'Inter',
            'Open Sans',
            'Playfair Display',
            'Merriweather',
            'Great Vibes',
            'Dancing Script',
            'Lobster',
            'Pacifico'
        ];

        const STICKER_COORDS = [
            { name: 'Cat', x: 29, y: 253, w: 214, h: 231 },
            { name: 'Unicorn', x: 240, y: 240, w: 190, h: 247 },
            { name: 'Cake', x: 429, y: 240, w: 182, h: 231 },
            { name: 'Heart', x: 629, y: 282, w: 186, h: 180 },
            { name: 'Star', x: 820, y: 284, w: 188, h: 185 },

            { name: 'Rainbow', x: 20, y: 546, w: 214, h: 210 },
            { name: 'Flower', x: 263, y: 538, w: 157, h: 240 },
            { name: 'Cupcake', x: 432, y: 546, w: 189, h: 218 },
            { name: 'Smiley', x: 628, y: 556, w: 175, h: 193 },
            { name: 'Paw', x: 825, y: 565, w: 179, h: 180 },
        ];

        const sheetImg = new Image();
        sheetImg.crossOrigin = "Anonymous";
        sheetImg.onload = () => {
            STICKER_COORDS.forEach(coord => {
                // Slice
                const c = document.createElement('canvas');
                c.width = coord.w;
                c.height = coord.h;
                const bx = c.getContext('2d');
                bx.drawImage(sheetImg, coord.x, coord.y, coord.w, coord.h, 0, 0, coord.w, coord.h);
                const dataUrl = c.toDataURL(); // extract sticker

                // UI Item
                const wrapper = document.createElement('div');
                wrapper.className = 'asset-item';
                wrapper.style.cssText = "background: rgba(255,255,255,0.1); cursor: pointer; padding: 5px; border-radius: 4px; display: flex; align-items: center; justify-content: center;";

                const thumb = document.createElement('img');
                thumb.src = dataUrl;
                thumb.style.cssText = "max-width: 100%; max-height: 100%; object-fit: contain; pointer-events: none;";

                wrapper.onclick = () => {
                    addStickerImage(dataUrl);
                    document.getElementById('modal-stickers').classList.add('hidden');
                };

                wrapper.appendChild(thumb);
                generalGrid.appendChild(wrapper);
            });
        };
        sheetImg.src = sheetUrl;

        // --- Properties Panel ---
        function showProperties(item) {
            const p = document.getElementById('prop-panel');
            const content = document.getElementById('props-content');
            content.innerHTML = '';

            p.style.transform = 'translateX(0)';

            // Common props
            content.appendChild(createPropCheckbox('Locked', item.locked || false, v => { item.locked = v; }));
            content.appendChild(createPropInput('X Position', item.x, v => { item.x = parseInt(v); Canvas2D.render(); }));
            content.appendChild(createPropInput('Y Position', item.y, v => { item.y = parseInt(v); Canvas2D.render(); }));

            if (item.type === 'text') {
                content.appendChild(createPropText('Content', item.text, v => {
                    item.text = v;
                    // Recalc width
                    const ctx = Canvas2D.ctxOut; // dummy
                    ctx.font = `${item.bold ? 'bold ' : ''}${item.fontSize}px ${item.fontFamily}`;
                    item.width = ctx.measureText(v).width;
                    Canvas2D.render();
                }));
                content.appendChild(createPropSelect('Font', item.fontFamily || 'Inter', FONTS, v => {
                    item.fontFamily = v;
                    const ctx = Canvas2D.ctxOut;
                    ctx.font = `${item.bold ? 'bold ' : ''}${item.italic ? 'italic ' : ''}${item.fontSize}px ${item.fontFamily}`;
                    item.width = ctx.measureText(item.text).width;
                    Canvas2D.render();
                }));

                content.appendChild(createPropInput('Font Size', item.fontSize, v => {
                    item.fontSize = parseInt(v);
                    item.height = parseInt(v); // approx
                    const ctx = Canvas2D.ctxOut;
                    ctx.font = `${item.bold ? 'bold ' : ''}${item.italic ? 'italic ' : ''}${item.fontSize}px ${item.fontFamily}`;
                    item.width = ctx.measureText(item.text).width;
                    Canvas2D.render();
                }));

                content.appendChild(createPropCheckbox('Bold', item.bold || false, v => {
                    item.bold = v;
                    const ctx = Canvas2D.ctxOut;
                    ctx.font = `${item.bold ? 'bold ' : ''}${item.italic ? 'italic ' : ''}${item.fontSize}px ${item.fontFamily}`;
                    item.width = ctx.measureText(item.text).width;
                    Canvas2D.render();
                }));

                content.appendChild(createPropCheckbox('Italic', item.italic || false, v => {
                    item.italic = v;
                    // Recalc logic duplicated for safety
                    const ctx = Canvas2D.ctxOut;
                    ctx.font = `${item.bold ? 'bold ' : ''}${item.italic ? 'italic ' : ''}${item.fontSize}px ${item.fontFamily}`;
                    item.width = ctx.measureText(item.text).width;
                    Canvas2D.render();
                }));
                content.appendChild(createPropColor('Color', item.color, v => { item.color = v; Canvas2D.render(); }));
                content.appendChild(createPropColor('Color', item.color, v => { item.color = v; Canvas2D.render(); }));
            } else if (item.type === 'shape') {
                content.appendChild(createPropInput('Width', item.width, v => { item.width = parseInt(v); Canvas2D.render(); }));
                content.appendChild(createPropInput('Height', item.height, v => { item.height = parseInt(v); Canvas2D.render(); }));
                content.appendChild(createPropCheckbox('Lock Ratio', item.ratioLocked !== false, v => { item.ratioLocked = v; }));
                content.appendChild(createPropColor('Color', item.color, v => { item.color = v; Canvas2D.render(); }));
            }
            // For images (if we had properties for them specifically other than common ones, or if we want to show it there)
            if (item.type === 'image') {
                content.appendChild(createPropCheckbox('Lock Ratio', item.ratioLocked !== false, v => { item.ratioLocked = v; }));
            }

            // Auto-open properties on selection if mobile
            if (window.innerWidth <= 768 && item) {
                const panelRight = document.querySelector('.panel-right');
                const backdrop = document.getElementById('mobile-backdrop');
                if (panelRight && backdrop) {
                    panelRight.classList.add('open');
                    backdrop.classList.add('active');
                }
            }
        }

        function createPropInput(label, val, onChange) {
            const div = document.createElement('div');
            div.className = 'control-group';
            div.innerHTML = `<label>${label}</label><input type="number" value="${val}">`;
            div.querySelector('input').oninput = (e) => onChange(e.target.value);
            return div;
        }

        function createPropText(label, val, onChange) {
            const div = document.createElement('div');
            div.className = 'control-group';
            div.innerHTML = `<label>${label}</label><input type="text" value="${val}">`;
            div.querySelector('input').oninput = (e) => onChange(e.target.value);
            return div;
        }

        function createPropColor(label, val, onChange) {
            const div = document.createElement('div');
            div.className = 'control-group';
            div.innerHTML = `<label>${label}</label><input type="color" value="${val}" style="width:100%; height:30px;">`;
            div.querySelector('input').oninput = (e) => onChange(e.target.value);
            return div;
        }

        function createPropSelect(label, val, options, onChange) {
            const div = document.createElement('div');
            div.className = 'control-group';
            let opts = options.map(o => `<option value="${o}" ${o === val ? 'selected' : ''}>${o}</option>`).join('');
            div.innerHTML = `<label>${label}</label><select>${opts}</select>`;
            div.querySelector('select').onchange = (e) => onChange(e.target.value);
            return div;
        }

        function createPropCheckbox(label, val, onChange) {
            const div = document.createElement('div');
            div.className = 'control-group';
            div.style.cssText = "flex-direction: row; align-items: center; justify-content: space-between;";
            div.innerHTML = `<label>${label}</label><input type="checkbox" ${val ? 'checked' : ''}>`;
            div.querySelector('input').onchange = (e) => onChange(e.target.checked);
            return div;
        }

        document.getElementById('btn-close-props').onclick = () => {
            document.getElementById('prop-panel').style.transform = 'translateX(110%)';
            STATE.selectedElement = null;
            Canvas2D.render();
            if (STATE.viewMode === 'orbit') controls.enabled = true;
        };

        document.getElementById('btn-delete-element').onclick = () => {
            if (!STATE.selectedElement) return;
            STATE.layers.outside = STATE.layers.outside.filter(i => i !== STATE.selectedElement);
            STATE.layers.inside = STATE.layers.inside.filter(i => i !== STATE.selectedElement);
            STATE.selectedElement = null;
            Canvas2D.render();
            document.getElementById('btn-close-props').click();
        };




        // Drop on Canvas
        window.addEventListener('dragover', e => e.preventDefault());
        window.addEventListener('drop', (e) => {
            e.preventDefault();

            // This is a global drop, we need to Raycast to see where it lands OR if view is locked, just place.
            if (STATE.draggedImageSrc && STATE.viewMode !== 'orbit') {
                const isInside = STATE.viewMode.includes('inside');
                const list = isInside ? STATE.layers.inside : STATE.layers.outside;

                const img = new Image();
                img.src = STATE.draggedImageSrc;
                img.onload = () => {
                    // Calculate drop pos relative to canvas
                    // Simple assumption: Center of screen / view for now if precise raycasting of drag event is hard without dragover monitoring
                    let x = isInside ? (STATE.viewMode === 'inside-right' ? Canvas2D.width * 0.75 : Canvas2D.width * 0.25)
                        : (STATE.viewMode === 'front' ? Canvas2D.width * 0.75 : Canvas2D.width * 0.25);

                    const ratio = img.width / img.height;
                    const h = 400;
                    const w = h * ratio;

                    list.push({
                        id: Date.now(),
                        type: 'image',
                        imgElement: img,
                        src: STATE.draggedImageB64 || STATE.draggedImageSrc,
                        x: x, y: Canvas2D.height / 2,
                        width: w, height: h,
                        rotation: 0
                    });
                    Canvas2D.render();
                };
            }
        });

        // Import Scanned Card
        document.getElementById('btn-import-scan').onclick = () => {
            // Instructions
            showCustomAlert(
                "Make a 3D card from your home-made or store-bought card.\n\nCreate your design on **standard letter-size paper** (8.5 x 11 inches) or scan an existing card.\n\nPlease save your scans/photos as **JPG or PNG** files.",
                "Import Instructions",
                () => {
                    // Step 1: Alert then Open File Picker
                    showCustomAlert(
                        "Step 1: Select the image for the FRONT/BACK (Outside) of the paper.",
                        "Import - Step 1/2",
                        () => {
                            document.getElementById('file-input-scan-front').click();
                        }
                    );
                }
            );
        };


        document.getElementById('file-input-scan-front').onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (evt) => {
                const img = new Image();
                img.onload = () => {
                    STATE.layers.outside = [{
                        id: 'scan-out', type: 'image', imgElement: img,
                        src: evt.target.result, // Persist data
                        x: Canvas2D.width / 2, y: Canvas2D.height / 2,
                        width: Canvas2D.width, height: Canvas2D.height,
                        locked: true
                    }];
                    Canvas2D.render();

                    e.target.value = ''; // Reset for re-use

                    // Chain next step with consistent UI
                    showCustomAlert(
                        "Great! Now select the image for the INSIDE of the paper.",
                        "Import - Step 2/2",
                        () => {
                            document.getElementById('file-input-scan-back').click();
                        }
                    );
                };
                img.onerror = () => showCustomAlert("Failed to load Front image.", "Error");
                img.src = evt.target.result;
            };
            reader.readAsDataURL(file);
        };

        document.getElementById('file-input-scan-back').onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (evt) => {
                const img = new Image();
                img.onload = () => {
                    STATE.layers.inside = [{
                        id: 'scan-in', type: 'image', imgElement: img,
                        src: evt.target.result, // Persist data
                        x: Canvas2D.width / 2, y: Canvas2D.height / 2,
                        width: Canvas2D.width, height: Canvas2D.height,
                        locked: true
                    }];
                    Canvas2D.render();
                    e.target.value = ''; // Reset
                };
                img.onerror = () => showCustomAlert("Failed to load Inside image.", "Error");
                img.src = evt.target.result;
            };
            reader.readAsDataURL(file);
        };

        // --- Camera Logic ---
        STATE.camera = {
            stream: null,
            track: null,
            facingMode: 'environment',
            step: 'outside', // 'outside' or 'inside'
        };

        const videoEl = document.getElementById('camera-feed');
        const guideEl = document.getElementById('camera-guide');
        const camModal = document.getElementById('modal-camera');
        const previewDiv = document.getElementById('camera-preview');
        const previewImg = document.getElementById('preview-img');

        // Check support
        // We always show the button now so users can see it, but we'll show an error if clicked and not supported.
        document.getElementById('btn-camera-scan').classList.remove('hidden');

        /*
        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            document.getElementById('btn-camera-scan').classList.remove('hidden');
        }
        */

        document.getElementById('btn-camera-scan').onclick = () => {
            STATE.camera.step = 'outside';
            startCamera();
        };

        async function startCamera() {
            try {
                // Attempt to lock screen orientation to portrait
                // This prevents UI buttons from disappearing when rotating phone
                if (screen.orientation && screen.orientation.lock) {
                    try {
                        if (document.documentElement.requestFullscreen) {
                            await document.documentElement.requestFullscreen();
                        }
                        await screen.orientation.lock('portrait');
                    } catch (e) {
                        console.warn("Orientation lock/Fullscreen failed:", e);
                    }
                }

                if (STATE.camera.stream) stopCamera();

                const constraints = {
                    video: {
                        facingMode: STATE.camera.facingMode,
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    },
                    audio: false
                };

                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error("Camera API not available. This usually happens when accessing via HTTP simply by IP. Please use HTTPS or localhost, or check 'chrome://flags/#unsafely-treat-insecure-origin-as-secure' to enable testing.");
                }

                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                STATE.camera.stream = stream;
                STATE.camera.track = stream.getVideoTracks()[0];
                videoEl.srcObject = stream;

                camModal.classList.remove('hidden');
                previewDiv.style.display = 'none';

                showToast("Step 1: Capture Front/Outside");

            } catch (err) {
                console.error("Camera Error:", err);
                showCustomAlert("Camera Error: " + err.message, "Error");
            }
        }

        function stopCamera() {
            // Unlock orientation and exit fullscreen
            if (screen.orientation && screen.orientation.unlock) {
                try { screen.orientation.unlock(); } catch (e) { }
            }
            if (document.fullscreenElement) {
                try { document.exitFullscreen(); } catch (e) { }
            }

            if (STATE.camera.stream) {
                STATE.camera.stream.getTracks().forEach(t => t.stop());
                STATE.camera.stream = null;
            }
            camModal.classList.add('hidden');
        }

        document.getElementById('btn-cam-cancel').onclick = stopCamera;

        document.getElementById('btn-cam-switch').onclick = () => {
            STATE.camera.facingMode = STATE.camera.facingMode === 'user' ? 'environment' : 'user';
            startCamera();
        };

        document.getElementById('btn-cam-capture').onclick = () => {
            const canvas = document.getElementById('camera-canvas');
            const ctx = canvas.getContext('2d');

            // Video dimensions
            const vW = videoEl.videoWidth;
            const vH = videoEl.videoHeight;

            // Landscape enforcement logic
            // If the video feed is portrait (vH > vW), it means user is holding phone vertically.
            // But we want to treat the content as landscape (horizontal card).
            // We'll capture normally, but if we detect portrait video, we might need to rotate the result
            // OR we just rely on the user rotating the phone. 
            // The prompt says "expect user to tilt horizontal". 
            // If they tilt horizontal, vW > vH usually (depending on browser/OS lock).
            // BUT if lock is on, vH > vW. 

            canvas.width = vW;
            canvas.height = vH;
            ctx.drawImage(videoEl, 0, 0, vW, vH);

            const vRect = videoEl.getBoundingClientRect();
            const gRect = guideEl.getBoundingClientRect();

            const scaleX = vW / vRect.width;
            const scaleY = vH / vRect.height;

            const cropX = Math.max(0, (gRect.left - vRect.left) * scaleX);
            const cropY = Math.max(0, (gRect.top - vRect.top) * scaleY);
            const cropW = Math.min(vW - cropX, gRect.width * scaleX);
            const cropH = Math.min(vH - cropY, gRect.height * scaleY);

            const cropCanvas = document.createElement('canvas');
            // We want final result to be Landscape (Width > Height)
            // If capture is portrait (Height > Width), we rotate -90 deg.

            const isPortraitCapture = cropH > cropW;

            if (isPortraitCapture) {
                // Rotate
                cropCanvas.width = cropH;
                cropCanvas.height = cropW;
                const cCtx = cropCanvas.getContext('2d');
                cCtx.translate(0, cropW);
                cCtx.rotate(-90 * Math.PI / 180);
                cCtx.drawImage(canvas, cropX, cropY, cropW, cropH, 0, 0, cropW, cropH);
            } else {
                cropCanvas.width = cropW;
                cropCanvas.height = cropH;
                const cCtx = cropCanvas.getContext('2d');
                cCtx.drawImage(canvas, cropX, cropY, cropW, cropH, 0, 0, cropW, cropH);
            }

            // Show Preview
            const dataUrl = cropCanvas.toDataURL('image/jpeg', 0.9);
            previewImg.src = dataUrl;
            previewDiv.style.display = 'flex';
        };

        document.getElementById('btn-cam-retake').onclick = () => {
            previewDiv.style.display = 'none';
        };

        document.getElementById('btn-cam-use').onclick = () => {
            const dataUrl = previewImg.src;
            const img = new Image();
            img.onload = () => {
                const item = {
                    id: 'scan-' + STATE.camera.step,
                    type: 'image',
                    imgElement: img,
                    src: dataUrl,
                    x: Canvas2D.width / 2, y: Canvas2D.height / 2,
                    width: Canvas2D.width, height: Canvas2D.height,
                    locked: true
                };

                if (STATE.camera.step === 'outside') {
                    STATE.layers.outside = [item];
                    Canvas2D.render();

                    // Move to Step 2
                    showToast("Front Captured! Now capture Inside.");
                    STATE.camera.step = 'inside';
                    previewDiv.style.display = 'none';
                    // Stay in camera mode
                } else {
                    STATE.layers.inside = [item];
                    Canvas2D.render();
                    stopCamera();
                    showCustomAlert("Card Scan Complete!", "Success");
                }
            };
            img.src = dataUrl;
        };


        // --- Export / Persistence Logic ---
        // Helper to rebuild layers with images
        async function hydrateLayers(layers) {
            const hydrated = [];
            for (let l of layers) {
                const item = { ...l };
                if (item.type === 'image' && item.src) {
                    await new Promise((resolve) => {
                        const img = new Image();
                        img.onload = () => resolve();
                        img.onerror = () => resolve();
                        img.src = item.src;
                        item.imgElement = img;
                    });
                }
                hydrated.push(item);
            }
            return hydrated;
        }

        async function renderCardToDataUrls(outsideLayers, insideLayers) {
            const lOut = await hydrateLayers(outsideLayers);
            const lIn = await hydrateLayers(insideLayers);

            const cOut = document.createElement('canvas');
            cOut.width = Canvas2D.width;
            cOut.height = Canvas2D.height;
            const ctxOut = cOut.getContext('2d');

            const cIn = document.createElement('canvas');
            cIn.width = Canvas2D.width;
            cIn.height = Canvas2D.height;
            const ctxIn = cIn.getContext('2d');

            ctxOut.fillStyle = '#ffffff';
            ctxOut.fillRect(0, 0, cOut.width, cOut.height);
            ctxIn.fillStyle = '#ffffff';
            ctxIn.fillRect(0, 0, cIn.width, cIn.height);

            Canvas2D.drawGuide(ctxOut);
            Canvas2D.drawGuide(ctxIn);

            lOut.forEach(l => Canvas2D.drawLayer(ctxOut, l));
            lIn.forEach(l => Canvas2D.drawLayer(ctxIn, l));

            return {
                dataOut: cOut.toDataURL('image/jpeg', 0.8),
                dataIn: cIn.toDataURL('image/jpeg', 0.8)
            };
        }

        // --- Custom UI Helpers ---
        function showToast(message, duration = 3000, color = 'var(--accent-color)') {
            const toast = document.createElement('div');
            toast.innerText = message;
            toast.style.cssText = `position:fixed; bottom:20px; left:50%; transform:translateX(-50%); background:${color}; color:white; padding:10px 20px; border-radius:20px; font-family:sans-serif; z-index:10001; box-shadow:0 4px 12px rgba(0,0,0,0.5); font-weight:500; opacity:0; transition:opacity 0.3s;`;
            document.body.appendChild(toast);

            requestAnimationFrame(() => toast.style.opacity = '1');

            setTimeout(() => {
                toast.style.opacity = '0';
                setTimeout(() => document.body.removeChild(toast), 300);
            }, duration);
        }

        function showCustomAlert(message, title = "Alert", onCloseCallback = null) {
            const overlay = document.createElement('div');
            overlay.style.cssText = "position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.7); z-index:20000; display:flex; align-items:center; justify-content:center; font-family:sans-serif;";

            const box = document.createElement('div');
            box.style.cssText = "background:var(--panel-bg); backdrop-filter:blur(10px); border:1px solid var(--panel-border); padding:20px; border-radius:12px; width:300px; box-shadow:0 10px 40px rgba(0,0,0,0.5); text-align:center;";

            box.innerHTML = `
                <h3 style="margin-top:0; color:white;">${title}</h3>
                <p style="color:#ddd; font-size:0.95rem; margin-bottom:20px;">${message}</p>
                <button id="btn-custom-alert-ok" style="background:var(--accent-color); border:none; color:white; padding:8px 20px; border-radius:6px; cursor:pointer;">OK</button>
            `;

            overlay.appendChild(box);
            document.body.appendChild(overlay);

            // Animate
            box.style.transform = "scale(0.9)";
            box.style.transition = "transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275)";
            requestAnimationFrame(() => box.style.transform = "scale(1)");

            const close = () => {
                overlay.style.opacity = "0";
                overlay.style.transition = "opacity 0.2s";
                setTimeout(() => document.body.removeChild(overlay), 200);
            };

            box.querySelector('#btn-custom-alert-ok').onclick = () => {
                close();
                if (onCloseCallback) onCloseCallback();
            };
            box.querySelector('#btn-custom-alert-ok').focus();
        }

        function getRobustViewerHTML(dataOut, dataIn) {
            return `<!DOCTYPE html>
<html>
<head>
    <title>Card Viewer</title>
    <style>
        body{ margin:0; overflow:hidden; background:#222; font-family: sans-serif; }
        #error-log { position: fixed; top: 10px; left: 10px; color: #f55; background: rgba(0,0,0,0.8); padding: 10px; display: none; z-index: 999; pointer-events: none; }
        .controls { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 100; display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; width: 95%; pointer-events: none; }
        .controls button { pointer-events: auto; background: rgba(0,0,0,0.6); color: white; border: 1px solid rgba(255,255,255,0.4); padding: 8px 16px; border-radius: 20px; cursor: pointer; font-family: sans-serif; font-size: 14px; transition: background 0.2s; white-space: nowrap; }
        .controls button:hover { background: rgba(255,255,255,0.2); }
        .card-maker-btn { background: rgba(100, 108, 255, 0.6) !important; border-color: rgba(100, 108, 255, 0.8) !important; color: white !important; font-weight: bold; text-decoration: none; }
        
        @media (min-resolution: 2dppx), (max-width: 600px) {
            .controls { bottom: 30px; gap: 8px; width: 98%; }
            .controls button { 
                padding: 16px 4px; 
                font-size: 16px; 
                border-width: 2px; 
                flex: 1 1 0; /* Distribute space equally */
                min-width: 0; /* Allow shrinking if needed */
            }
            .card-maker-btn { flex: 0 0 auto !important; width: auto; padding-left: 15px !important; padding-right: 15px !important; }
        }
    </style>
    <script>
        window.onerror = function(msg, url, line, col, error) {
            const div = document.getElementById('error-log');
            if(div) {
                div.style.display = 'block';
                div.innerHTML += "Error: " + msg + "<br>Line: " + line + "<br>";
            }
            console.error(error);
        };
    <\/script>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"><\/script>
    <script type="importmap">{"imports":{"three":"https://unpkg.com/three@0.160.0/build/three.module.js"}}<\/script>
</head>
<body>
<div id="error-log"></div>
<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';

    try {
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 100);
        
        const renderer = new THREE.WebGLRenderer({antialias:true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // --- Helper Functions ---
        function onWindowResize() {
            const w = window.innerWidth, h = window.innerHeight;
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
            renderer.setSize(w, h);
            
            const aspect = w / h;
            const vFov = camera.fov * (Math.PI / 180);
            
            // Match "Front" view logic for initial load
            const PAD = 1.05; 
            const fitH = (8.5 * PAD) / Math.tan(vFov / 2); 
            // Use 5.5 width (single panel) for initial "Front" look
            const fitW = (5.5 * PAD) / (Math.tan(vFov / 2) * aspect); 
            
            // Apply same closer multiplier (0.65)
            const safeZ = Math.max(5, fitH, fitW) * 0.65;
            camera.position.z = Math.max(safeZ, 5); 
        }
        window.addEventListener('resize', onWindowResize);
        
        // --- Scene Setup ---
        scene.add(new THREE.AmbientLight(0xffffff, 1.5));
        const dl = new THREE.DirectionalLight(0xffffff, 0.6); dl.position.set(5,10,7); scene.add(dl);

        // Geometry
        const w=5.5, h=8.5;
        const gBase = new THREE.PlaneGeometry(w, h);
        const THICKNESS = 0.01;
        const OFFSET = w/2;

        // Textures
        const texOut = new THREE.TextureLoader().load('${dataOut}');
        const texIn = new THREE.TextureLoader().load('${dataIn}');
        texOut.colorSpace = THREE.SRGBColorSpace;
        texIn.colorSpace = THREE.SRGBColorSpace;
        
        const matOut = new THREE.MeshStandardMaterial({
            map:texOut, side:THREE.FrontSide, roughness: 0.6, metalness: 0.0
        });
        const matIn = new THREE.MeshStandardMaterial({
            map:texIn, side:THREE.FrontSide, roughness: 0.6, metalness: 0.0
        });

        // Group Hierarchy
        const cardWrapper = new THREE.Group();
        scene.add(cardWrapper);

        const leftGroup = new THREE.Group();
        const rightGroup = new THREE.Group();
        
        leftGroup.position.set(0, 0, THICKNESS);
        rightGroup.position.set(0, 0, 0);

        cardWrapper.add(leftGroup);
        cardWrapper.add(rightGroup);
        
        function setUVs(geo, min, max) {
            const uvs = geo.attributes.uv;
            for(let i=0; i<uvs.count; i++){
                let u = uvs.getX(i);
                u = min + u * (max - min);
                uvs.setX(i, u);
            }
        }

        // --- Mesh Construction ---
        // Left Wing
        const lIn = new THREE.Mesh(gBase.clone(), matIn); 
        lIn.position.set(-OFFSET, 0, 0); 
        setUVs(lIn.geometry, 0, 0.5); 
        leftGroup.add(lIn);
        
        const lOut = new THREE.Mesh(gBase.clone(), matOut); 
        lOut.position.set(-OFFSET, 0, -THICKNESS);
        lOut.rotation.y = Math.PI; 
        setUVs(lOut.geometry, 0.5, 1.0); 
        leftGroup.add(lOut);

        // Right Wing
        const rIn = new THREE.Mesh(gBase.clone(), matIn); 
        rIn.position.set(OFFSET, 0, 0); 
        setUVs(rIn.geometry, 0.5, 1.0);
        rightGroup.add(rIn);
        
        const rOut = new THREE.Mesh(gBase.clone(), matOut); 
        rOut.position.set(OFFSET, 0, -THICKNESS);
        rOut.rotation.y = Math.PI; 
        setUVs(rOut.geometry, 0.0, 0.5);
        rightGroup.add(rOut);
        
        // --- State ---
        const CLOSED_ANGLE = Math.PI * 0.95; 
        const OPEN_ANGLE = Math.PI * 0.05; 
        let targetAngle = CLOSED_ANGLE; 
        leftGroup.rotation.y = CLOSED_ANGLE;

        // Camera / Rotation State
        let rotationTargetZ = 0; 
        let rotationTargetY = 0;
        let isLandscape = false;
        
        let cameraTargetPos = null;
        let cameraTargetLook = null;
        let cameraTweenTime = 0;
        const CAMERA_DURATION = 1000;

        // Init Camera
        camera.position.set(0, 5, 15);
        onWindowResize();

        // --- Interaction ---
        let isDragging = false;
        document.addEventListener('mousedown', () => isDragging = false);
        document.addEventListener('mousemove', () => isDragging = true);
        document.addEventListener('mouseup', (e) => {
            if (e.target.closest && e.target.closest('.controls')) return;
            if (!isDragging) {
                 targetAngle = (Math.abs(targetAngle - CLOSED_ANGLE) < 0.1) ? OPEN_ANGLE : CLOSED_ANGLE;
            }
        });

        // --- Tweening Helpers ---
        function tweenCamera(pos, look) {
             cameraTargetPos = pos.clone();
             cameraTargetLook = look.clone();
             cameraTweenTime = 0;
             controls.enabled = false;
        }

        function tweenCameraToSafeZ(sign, widthToFit = 11.0) {
             const aspect = window.innerWidth / window.innerHeight;
             const vFov = camera.fov * (Math.PI / 180);
             const PAD = 1.05; // Tighter padding (zoom closer)
             const fitH = (8.5 * PAD) / Math.tan(vFov / 2);
             const fitW = (widthToFit * PAD) / (Math.tan(vFov / 2) * aspect);
             // Use 5 instead of 10 as minimum to allow closer zoom on mobile
             // Multiplier 0.65 brings it much closer
             const safeZ = Math.max(5, fitH, fitW) * 0.65 * sign; 
             tweenCamera(new THREE.Vector3(0, 0, safeZ), new THREE.Vector3(0, 0, 0));
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            
            // 1. Fold
            leftGroup.rotation.y += (targetAngle - leftGroup.rotation.y) * 0.05;
            
            // 2. Global Rotation
            cardWrapper.rotation.z += (rotationTargetZ - cardWrapper.rotation.z) * 0.05;
            cardWrapper.rotation.y += (rotationTargetY - cardWrapper.rotation.y) * 0.05;

            // 3. Camera Tween
            if (cameraTargetPos && cameraTargetLook) {
                 cameraTweenTime += 16.66;
                 let t = Math.min(cameraTweenTime / CAMERA_DURATION, 1);
                 
                 camera.position.lerp(cameraTargetPos, 0.1); 
                 controls.target.lerp(cameraTargetLook, 0.1);
                 
                 if (camera.position.distanceTo(cameraTargetPos) < 0.1 && t >= 1) {
                     cameraTargetPos = null;
                     controls.enabled = true;
                 }
            } else {
                 if (controls.enabled) {
                     const tipX = -5.5 * Math.cos(leftGroup.rotation.y);
                     
                     // Bounding Box Logic for correct centering
                     const minX = Math.min(0, tipX);
                     const maxX = 5.5;
                     const visCenterLocal = (minX + maxX) / 2;
                     
                     const sign = (Math.abs(rotationTargetY) > 2) ? -1 : 1; 
                     const targetX = visCenterLocal * sign;
                     
                     const delta = (targetX - controls.target.x) * 0.1;
                     controls.target.x += delta;
                     camera.position.x += delta;
                 }
            }

            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // --- UI Handlers ---
        // Helpers to reset orientation
        function resetOrientation() {
             isLandscape = false;
             rotationTargetZ = 0;
        }

        window.btnFront = () => {
             targetAngle = CLOSED_ANGLE;
             rotationTargetY = 0;
             resetOrientation();
             tweenCameraToSafeZ(1, 5.5); // Fit single panel
        };
        
        window.btnInside = () => {
             targetAngle = OPEN_ANGLE;
             rotationTargetY = 0;
             resetOrientation();
             tweenCameraToSafeZ(1, 11.0); // Fit full spread
        };

        window.btnBack = () => {
             targetAngle = CLOSED_ANGLE;
             rotationTargetY = Math.PI;
             resetOrientation();
             tweenCameraToSafeZ(1, 5.5); // Fit single panel
        };
        
        window.btnRotate = () => {
             isLandscape = !isLandscape;
             rotationTargetZ = isLandscape ? -Math.PI/2 : 0;
        };

    } catch (e) {
        document.getElementById('error-log').style.display = 'block';
        document.getElementById('error-log').innerText = "Runtime Error: " + e.message;
        console.error(e);
    }
<\/script>

<div class="controls">
    <button onclick="window.open('https://prod.d11b9xr1x72gdk.amplifyapp.com/','_blank')" class="card-maker-btn">Card Maker</button>
    <button onclick="window.btnFront()">Front</button>
    <button onclick="window.btnInside()">Inside</button>
    <button onclick="window.btnBack()">Back</button>
    <button onclick="window.btnRotate()">Rotate</button>
</div>
</body>
</html>`;
        }

        function getViewerHTML(dataOut, dataIn) {
            return `<!DOCTYPE html>
<html>
<head>
    <title>You've received a card!</title>
    <style>
        body{margin:0;overflow:hidden;background:#222;}
        .controls { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 100; display: flex; gap: 10px; }
        .controls button { background: rgba(0,0,0,0.6); color: white; border: 1px solid rgba(255,255,255,0.4); padding: 8px 16px; border-radius: 20px; cursor: pointer; font-family: sans-serif; font-size: 14px; transition: background 0.2s; }
        .controls button:hover { background: rgba(255,255,255,0.2); }
    </style>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"><\/script>
    <script type="importmap">{"imports":{"three":"https://unpkg.com/three@0.160.0/build/three.module.js"}}<\/script>
</head>
<body>
<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 100);
    
    // Renderer
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // Responsive Logic
    function onWindowResize() {
        const w = window.innerWidth, h = window.innerHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
        
        const aspect = w / h;
        const vFov = camera.fov * (Math.PI / 180);
        const fitH = (Math.max(8.5, 8.5) * 1.05) / Math.tan(vFov / 2); // Ensure min height 8.5
        const fitW = (Math.max(11.0, 5.5) * 1.05) / (Math.tan(vFov / 2) * aspect); // Ensure min width 5.5 (Closed)
        const sphereDist = (7.0 * 1.05) / Math.sin(vFov / 2);
        const safeZ = Math.max(5, fitH, fitW, sphereDist) * 0.7;
        camera.position.z = safeZ;
        camera.position.y = 5; // Look down slightly
    }
    window.addEventListener('resize', onWindowResize);
    onWindowResize(); // Init position
    
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dl = new THREE.DirectionalLight(0xffffff, 0.8); dl.position.set(5,10,7); scene.add(dl);

    // Geometry
    const w=5.5, h=8.5;
    const gBase = new THREE.PlaneGeometry(w, h); // Base geometry
    const THICKNESS = 0.01;
    const OFFSET = w/2;

    // Materials
    const texOut = new THREE.TextureLoader().load('${dataOut}');
    const texIn = new THREE.TextureLoader().load('${dataIn}');
    texOut.colorSpace = THREE.SRGBColorSpace;
    texIn.colorSpace = THREE.SRGBColorSpace;
    
    const matOut = new THREE.MeshBasicMaterial({map:texOut, side:THREE.FrontSide});
    const matIn = new THREE.MeshBasicMaterial({map:texIn, side:THREE.FrontSide});

    const cardWrapper = new THREE.Group();
    scene.add(cardWrapper);

    const leftGroup = new THREE.Group();
    const rightGroup = new THREE.Group();
    // Front wing (Left) sits on top of Back wing (Right)
    leftGroup.position.z = THICKNESS * 2; 

    cardWrapper.add(leftGroup);
    cardWrapper.add(rightGroup);
    
    // Helper
    function setUVs(geo, min, max) {
        const uvs = geo.attributes.uv;
        for(let i=0; i<uvs.count; i++){
            let u = uvs.getX(i);
            u = min + u * (max - min);
            uvs.setX(i, u);
        }
    }

    // Left Wing (Front Cover + Inside Left)
    const lIn = new THREE.Mesh(gBase.clone(), matIn); 
    lIn.position.set(-OFFSET, 0, THICKNESS);
    setUVs(lIn.geometry, 0, 0.5); // Inside Left
    leftGroup.add(lIn);
    
    const lOut = new THREE.Mesh(gBase.clone(), matOut); 
    lOut.position.set(-OFFSET, 0, -THICKNESS);
    lOut.rotation.y = Math.PI; 
    setUVs(lOut.geometry, 0.5, 1.0); // Fixed Front
    leftGroup.add(lOut);

    // Right Wing (Back Cover + Inside Right)
    const rIn = new THREE.Mesh(gBase.clone(), matIn); 
    rIn.position.set(OFFSET, 0, THICKNESS);
    setUVs(rIn.geometry, 0.5, 1.0);
    rightGroup.add(rIn);
    
    const rOut = new THREE.Mesh(gBase.clone(), matOut); 
    rOut.position.set(OFFSET, 0, -THICKNESS);
    rOut.rotation.y = Math.PI; 
    setUVs(rOut.geometry, 0.0, 0.5); // Fixed Back
    rightGroup.add(rOut);
    
    // Interaction State
    const CLOSED_ANGLE = Math.PI * 0.9; // 90% Closed
    const OPEN_ANGLE = Math.PI * 0.1;   // 90% Open
    let targetAngle = CLOSED_ANGLE; 
    leftGroup.rotation.y = CLOSED_ANGLE;

    let isDragging = false;
    document.addEventListener('mousedown', () => isDragging = false);
    document.addEventListener('mousemove', () => isDragging = true);
    document.addEventListener('mouseup', (e) => {
        if (e.target.closest && e.target.closest('.controls')) return;
        if (!isDragging) {
             targetAngle = (targetAngle === CLOSED_ANGLE) ? OPEN_ANGLE : CLOSED_ANGLE;
        }
    });

    // --- Camera Tweening ---
    let cameraTargetPos = null;
    let cameraTargetLook = null;
    let cameraTweenTime = 0;
    const CAMERA_DURATION = 1000; // ms

    function tweenCamera(targetPos, targetLook) {
        cameraTargetPos = targetPos.clone();
        cameraTargetLook = targetLook.clone();
        cameraTweenTime = 0;
        
        // Disable controls during tween
        controls.enabled = false;
    }

    // --- Rotation Tweening ---
    let rotationTargetZ = 0; // Landscape/Portrait
    let rotationTargetY = 0; // Front/Back flip

    function animate(time) {
        requestAnimationFrame(animate);
        
        // 1. Fold Animation
        const currentAngle = leftGroup.rotation.y;
        const nextAngle = currentAngle + (targetAngle - currentAngle) * 0.05;
        leftGroup.rotation.y = nextAngle;
        
        // 2. Card Orientation (Landscape/Portrait Z)
        // We act on cardWrapper.rotation.z
        const currentRotZ = cardWrapper.rotation.z;
        cardWrapper.rotation.z += (rotationTargetZ - currentRotZ) * 0.05;

        // 3. Card Flip (Front/Back Y)
        // We act on cardWrapper.rotation.y
        const currentRotY = cardWrapper.rotation.y;
        cardWrapper.rotation.y += (rotationTargetY - currentRotY) * 0.05;

        // 4. Camera Tweening (Still useful for Inside Views or reset)
        if (cameraTargetPos && cameraTargetLook) {
             const dt = 16.66;
             cameraTweenTime += dt;
             let t = Math.min(cameraTweenTime / CAMERA_DURATION, 1);
             const ease = t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;

             camera.position.lerp(cameraTargetPos, 0.05);
             controls.target.lerp(cameraTargetLook, 0.05);
             
             if (camera.position.distanceTo(cameraTargetPos) < 0.1) {
                 cameraTargetPos = null;
                 controls.enabled = true;
             }
        } 
        else {
            // Dynamic Centering Logic 
            if (controls.enabled) {
                // ... (Existing centering logic remains same)
                
                // IMPORTANT: When flipping to BACK (RotY=PI), the visual calculation changes.
                // Left Wing angle is relative to wrapper.
                // If Wrapper is rotated 180, the 'Left Wing' is on the Right.
                // But let's assume simple centroid centering of the visible bounding box.
                
                // Tip Local X = -5.5 * cos(angle).
                // If RotY = 0: World X = Tip Local X.
                // If RotY = PI: World X = -Tip Local X.
                
                // Calculate VISUAL bounding width effectively
                const tipLocalX = -5.5 * Math.cos(nextAngle);
                
                // Effective width for calculating Zoom is handled by our constant checks in 'resize' 
                // but here for Centering we just need roughly the centroid.
                
                const minX = Math.min(0, tipLocalX);
                const maxX = 5.5;
                const localCenter = (minX + maxX) / 2;
                
                // If rotated 180, the World Center is roughly -localCenter
                if (Math.abs(rotationTargetY) > 0.1) {
                    centerX = -localCenter;
                } else {
                    centerX = localCenter;
                }

                const delta = centerX - controls.target.x;
                controls.target.x += delta;
                camera.position.x += delta; 
            }
        }
        
        controls.update();
        renderer.render(scene, camera);
    }
    animate();

    // UI Logic
    document.getElementById('btn-open').onclick = () => targetAngle = OPEN_ANGLE;
    document.getElementById('btn-close').onclick = () => targetAngle = CLOSED_ANGLE;
    
    document.getElementById('btn-front').onclick = () => {
         // Face Front: Rotation Y = 0
         rotationTargetY = 0;
         tweenCameraToSafeZ(1); // Ensure positive Z
    };
    
    document.getElementById('btn-back').onclick = () => {
         // Face Back: Rotation Y = 180
         rotationTargetY = Math.PI;
         tweenCameraToSafeZ(1); // Still positive Z, looking at flipped card
    };

    function tweenCameraToSafeZ(sign) {
         onWindowResize(); 
         const aspect = window.innerWidth / window.innerHeight;
         const vFov = camera.fov * (Math.PI / 180);
         const fitH = (8.5 * 1.05) / Math.tan(vFov / 2);
         const fitW = (11.0 * 1.05) / (Math.tan(vFov / 2) * aspect);
         const sphereDist = (7.0 * 1.05) / Math.sin(vFov / 2);
         const safeZ = Math.max(10, fitH, fitW, sphereDist) * 0.7 * sign;
         tweenCamera(new THREE.Vector3(0, 0, safeZ), new THREE.Vector3(0, 0, 0));
    }

    let isLandscape = false;
    document.getElementById('btn-rotate').onclick = () => {
        isLandscape = !isLandscape;
        rotationTargetZ = isLandscape ? -Math.PI / 2 : 0;
    };

<\/script>
<div class="controls">
    <button id="btn-open">Open</button>
    <button id="btn-close">Close</button>
    <button id="btn-front">Front</button>
    <button id="btn-back">Back</button>
    <button id="btn-rotate">Rotate</button>
</div>
</body>
</html>`;
        }

        document.getElementById('btn-save-project').onclick = () => {
            // Create UI Overlay for Save
            const overlay = document.createElement('div');
            overlay.style.cssText = "position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.85); z-index:10000; display:flex; align-items:center; justify-content:center; font-family:sans-serif;";

            const box = document.createElement('div');
            box.style.cssText = "background:#333; padding:30px; border-radius:12px; border:1px solid #555; color:white; width:300px; display:flex; flex-direction:column; gap:15px; box-shadow:0 10px 30px rgba(0,0,0,0.5);";

            box.innerHTML = `
                <h3 style="margin:0; font-size:1.2rem;">Save Card</h3>
                <label style="font-size:0.9rem; color:#ccc;">Card Name:</label>
                <input type="text" id="save-card-name" value="My Card" style="padding:10px; border-radius:6px; border:1px solid #555; background:#222; color:white;">
                <div style="display:flex; justify-content:flex-end; gap:10px; margin-top:10px;">
                    <button id="btn-cancel-save" style="padding:8px 16px; background:transparent; border:1px solid #555; color:#ccc; border-radius:6px; cursor:pointer;">Cancel</button>
                    <button id="btn-confirm-save" style="padding:8px 16px; background:var(--accent-color); border:none; color:white; border-radius:6px; cursor:pointer; font-weight:bold;">Save</button>
                </div>
            `;

            overlay.appendChild(box);
            document.body.appendChild(overlay);

            const input = box.querySelector('#save-card-name');
            input.focus();
            input.select();

            const close = () => document.body.removeChild(overlay);

            box.querySelector('#btn-cancel-save').onclick = close;

            box.querySelector('#btn-confirm-save').onclick = () => {
                const name = input.value.trim() || "Untitled Card";

                const data = {
                    version: 1,
                    date: Date.now(),
                    outside: STATE.layers.outside.map(l => ({ ...l, imgElement: null })),
                    inside: STATE.layers.inside.map(l => ({ ...l, imgElement: null }))
                };

                try {
                    localStorage.setItem(`card_proj_${name}`, JSON.stringify(data));
                    showToast(`Saved "${name}"`);
                    close();
                } catch (e) {
                    showCustomAlert("Save failed (Storage Full?): " + e.message, "Save Error");
                }
            };

            // Enter key support
            input.onkeydown = (e) => {
                if (e.key === 'Enter') box.querySelector('#btn-confirm-save').click();
                if (e.key === 'Escape') close();
            };
        };

        const btnNew = document.getElementById('btn-new-card');
        btnNew.onclick = () => {
            const isEmpty = STATE.layers.outside.length === 0 && STATE.layers.inside.length === 0;
            // Remove native confirm
            // if (!isEmpty && !confirm("Start new card? Unsaved changes will be lost.")) return;

            STATE.layers.outside = [];
            STATE.layers.inside = [];
            STATE.selectedElement = null;
            Canvas2D.render();

            // Reset View
            updateFold(0.2);
            camera.position.set(2.75, 5, 15);
            controls.target.set(2.75, 0, 0);
            controls.update();

            // Simple toast
            showToast("New Card Started");
        };

        const btnCatalog = document.getElementById('btn-load-project');
        btnCatalog.innerText = "Load Card";

        btnCatalog.onclick = () => {
            // Create UI Overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = "position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.85); z-index:10000; display:flex; flex-direction:column; padding:40px; color:white; font-family:sans-serif;";

            const header = document.createElement('div');
            header.innerHTML = "<h2>Saved Cards Catalog</h2><p>Select a card to load (Unsaved changes will be lost):</p>";
            overlay.appendChild(header);



            const grid = document.createElement('div');
            grid.style.cssText = "display:grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap:20px; overflow-y:auto; padding:20px 0;";
            overlay.appendChild(grid);

            // Find Projects
            const keys = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith('card_proj_')) keys.push(key);
            }

            if (keys.length === 0) {
                grid.innerHTML = "<div>No saved projects found. Save one first!</div>";
            }

            keys.forEach(key => {
                const projName = key.replace('card_proj_', '');
                const raw = localStorage.getItem(key);
                let meta = {};
                try { meta = JSON.parse(raw); } catch (e) { }

                const cardir = document.createElement('div');
                cardir.style.cssText = "background:#333; border:1px solid #555; border-radius:8px; padding:15px; cursor:pointer; transition:0.2s;";
                cardir.innerHTML = `
                    <div style="font-weight:bold; font-size:1.1rem; margin-bottom:5px;">${projName}</div>
                    <div style="font-size:0.8rem; color:#aaa;">${new Date(meta.date || 0).toLocaleDateString()}</div>
                `;
                cardir.onmouseover = () => cardir.style.background = '#444';
                cardir.onmouseout = () => cardir.style.background = '#333';

                cardir.onclick = async () => {
                    const isEmpty = STATE.layers.outside.length === 0 && STATE.layers.inside.length === 0;
                    // Skip confirm to avoid browser blocking issues
                    // if (!isEmpty && !confirm(`Load "${projName}"? Unsaved changes will be lost.`)) return;

                    try {
                        const data = JSON.parse(localStorage.getItem(key));
                        // Rebuild state
                        STATE.layers.outside = await hydrateLayers(data.outside || []);
                        STATE.layers.inside = await hydrateLayers(data.inside || []);

                        STATE.selectedElement = null;
                        Canvas2D.render();
                        setMode('orbit');
                        updateFold(0.2); // Reset to 20% open
                        camera.position.set(2.75, 5, 15);
                        controls.target.set(2.75, 0, 0);
                        controls.update();

                        document.body.removeChild(overlay);
                    } catch (e) {
                        showCustomAlert("Failed to load project: " + e.message, "Load Error");
                    }
                };

                // View Button
                const viewBtn = document.createElement('button');
                viewBtn.innerText = "üëÅÔ∏è";
                viewBtn.title = "View Card";
                viewBtn.style.cssText = "float:right; background:transparent; border:none; color:#ddd; font-size:1.4rem; cursor:pointer; margin-top:-5px; margin-right: 10px; transition: color 0.2s;";
                viewBtn.onmouseover = () => viewBtn.style.color = 'white';
                viewBtn.onmouseout = () => viewBtn.style.color = '#ddd';

                viewBtn.onclick = async (e) => {
                    e.stopPropagation(); // Don't load the card
                    viewBtn.disabled = true;
                    viewBtn.innerText = "‚åõ";
                    try {
                        const data = JSON.parse(localStorage.getItem(key));
                        const { dataOut, dataIn } = await renderCardToDataUrls(data.outside || [], data.inside || []);
                        const html = getRobustViewerHTML(dataOut, dataIn);
                        const blob = new Blob([html], { type: 'text/html' });
                        const url = URL.createObjectURL(blob);
                        window.open(url, '_blank');
                    } catch (err) {
                        showCustomAlert("Failed to view: " + err.message, "View Error");
                    } finally {
                        viewBtn.disabled = false;
                        viewBtn.innerText = "üëÅÔ∏è";
                    }
                };
                cardir.insertBefore(viewBtn, cardir.firstChild);

                // Delete Button
                const delBtn = document.createElement('button');
                delBtn.innerText = "√ó";
                delBtn.title = "Delete Card";
                delBtn.style.cssText = "float:right; background:transparent; border:none; color:#f55; font-size:1.4rem; cursor:pointer; margin-top:-5px;";
                delBtn.onclick = (e) => {
                    e.stopPropagation();
                    if (delBtn.innerText === "√ó") {
                        delBtn.innerText = "Sure?";
                        delBtn.style.fontSize = "0.9rem";
                        delBtn.style.fontWeight = "bold";
                        setTimeout(() => {
                            if (cardir.parentElement) { // Check if still exists
                                delBtn.innerText = "√ó";
                                delBtn.style.fontSize = "1.4rem";
                            }
                        }, 3000);
                    } else {
                        localStorage.removeItem(key);
                        cardir.remove();
                    }
                };
                cardir.insertBefore(delBtn, cardir.firstChild);

                grid.appendChild(cardir);
            });

            const closeBtn = document.createElement('button');
            closeBtn.innerText = "Close Catalog";
            closeBtn.className = 'primary';
            closeBtn.style.cssText = "margin-top:auto; align-self:center; padding:10px 30px;";
            closeBtn.onclick = () => document.body.removeChild(overlay);
            overlay.appendChild(closeBtn);

            document.body.appendChild(overlay);
        };

        // Preview Card
        async function previewCardInBrowser() {
            const btn = document.getElementById('btn-preview-card');
            btn.innerText = "Generating...";
            btn.disabled = true;
            try {
                // Generate Texture Data URIs
                const dataOut = canvasOutside.toDataURL('image/jpeg', 0.8);
                const dataIn = canvasInside.toDataURL('image/jpeg', 0.8);

                const htmlContent = getRobustViewerHTML(dataOut, dataIn);

                // Create Blob and open
                const blob = new Blob([htmlContent], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                window.open(url, '_blank');
            } catch (err) {
                console.error(err);
                showCustomAlert("Failed to generate preview.", "Error");
            } finally {
                btn.innerText = "Preview in Browser";
                btn.disabled = false;
            }
        }
        document.getElementById('btn-preview-card').onclick = previewCardInBrowser;

        document.getElementById('btn-export-html').onclick = () => {
            // Remove confirm to avoid blocking
            // if (!confirm("This will download the card as a standalone HTML file which can be opened in any web browser.\n\nDo you want to continue?")) return;
            // Generate Texture Data URIs
            const dataOut = canvasOutside.toDataURL('image/jpeg', 0.8);
            const dataIn = canvasInside.toDataURL('image/jpeg', 0.8);

            // Minimal Viewer HTML
            const html = getRobustViewerHTML(dataOut, dataIn);

            const blob = new Blob([html], { type: 'text/html' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'greeting_card.html';
            a.click();
        };

        // --- Auth UI Management ---
        const authContainer = document.getElementById('amplify-auth-container');
        const authStatus = document.getElementById('auth-status');
        const loginBtn = document.getElementById('btn-login-toggle');
        const closeAuthBtn = document.getElementById('btn-close-auth');

        const authTitle = document.getElementById('auth-title');
        const authToggleBtn = document.getElementById('auth-toggle-btn');
        const authToggleText = document.getElementById('auth-toggle-text');
        const authSubmitBtn = document.getElementById('btn-auth-submit');
        const authMsg = document.getElementById('auth-message');

        const fieldUser = document.getElementById('auth-username');
        const fieldEmail = document.getElementById('auth-email');
        const fieldPass = document.getElementById('auth-password');
        const fieldCode = document.getElementById('auth-code');

        let authMode = 'signin'; // signin, signup, confirm

        async function updateAuthUI() {
            try {
                const user = await getCurrentUser();
                const attributes = await fetchUserAttributes();
                const display = attributes.email || user.username;
                authStatus.innerHTML = `Signed in as:<br><strong>${display}</strong>`;
                loginBtn.innerText = "Sign Out";

            } catch (e) {
                authStatus.innerText = "Guest Mode";
                loginBtn.innerText = "Sign In to Cloud";
                loginBtn.innerText = "Sign In to Cloud";
            }
        }

        authToggleBtn.onclick = () => {
            authMsg.innerText = '';
            if (authMode === 'signin') {
                authMode = 'signup';
                authTitle.innerText = 'Create Account';
                authSubmitBtn.innerText = 'Create Account';
                authToggleText.innerText = 'Have an account?';
                authToggleBtn.innerText = 'Sign In';
                fieldUser.placeholder = 'Email';
                fieldCode.classList.add('hidden');
                fieldPass.classList.remove('hidden');
            } else {
                authMode = 'signin';
                authTitle.innerText = 'Sign In';
                authSubmitBtn.innerText = 'Sign In';
                authToggleText.innerText = 'Need an account?';
                authToggleBtn.innerText = 'Create Account';
                fieldUser.placeholder = 'Email';
                fieldCode.classList.add('hidden');
                fieldPass.classList.remove('hidden');
            }
        };

        authSubmitBtn.onclick = async () => {
            const username = fieldUser.value; // Now contains the Email
            const password = fieldPass.value;
            const code = fieldCode.value;

            authMsg.innerText = '';
            authSubmitBtn.disabled = true;
            const originalText = authSubmitBtn.innerText;
            authSubmitBtn.innerText = 'Please wait...';

            try {
                if (authMode === 'signin') {
                    const { nextStep } = await signIn({ username, password });

                    if (nextStep.signInStep === 'CONFIRM_SIGN_UP') {
                        authMode = 'confirm';
                        authTitle.innerText = 'Confirm Account';
                        authSubmitBtn.innerText = 'Confirm';
                        fieldCode.classList.remove('hidden');
                        fieldPass.classList.add('hidden');
                    } else {
                        authContainer.classList.add('hidden');
                        updateAuthUI();
                    }
                } else if (authMode === 'signup') {
                    await signUp({
                        username,
                        password,
                        options: {
                            userAttributes: { email: username }
                        }
                    });
                    authMode = 'confirm';
                    authTitle.innerText = 'Confirm Account';
                    authSubmitBtn.innerText = 'Confirm';
                    fieldCode.classList.remove('hidden');
                    fieldPass.classList.add('hidden');
                    authMsg.style.color = 'var(--accent-color)';
                    authMsg.innerText = 'Code sent to ' + username;
                } else if (authMode === 'confirm') {
                    await confirmSignUp({ username, confirmationCode: code });
                    await autoSignIn();
                    authContainer.classList.add('hidden');
                    updateAuthUI();
                }
            } catch (err) {
                console.error("Auth error:", err);
                authMsg.style.color = '#ff6b6b';
                authMsg.innerText = err.message || "An error occurred";
            } finally {
                authSubmitBtn.disabled = false;
                authSubmitBtn.innerText = originalText;
            }
        };

        loginBtn.onclick = async () => {
            if (loginBtn.innerText === "Sign Out") {
                await signOut();
                updateAuthUI();
            } else {
                authContainer.classList.remove('hidden');
            }
        };

        closeAuthBtn.onclick = () => authContainer.classList.add('hidden');

        // Close auth modal when signed in
        Hub.listen('auth', ({ payload }) => {
            if (payload.event === 'signedIn') {
                authContainer.classList.add('hidden');
            }
            updateAuthUI();
        });

        // Initialize UI
        updateAuthUI();

        // --- Cloud Gallery & Publishing Logic ---
        document.getElementById('btn-shared-cards').onclick = openSharedCardsModal;

        async function openSharedCardsModal() {
            // Create UI Overlay (Similar to Load Card)
            const overlay = document.createElement('div');
            overlay.style.cssText = "position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.85); z-index:10000; display:flex; flex-direction:column; padding:40px; color:white; font-family:sans-serif;";

            const header = document.createElement('div');
            header.innerHTML = "<h2>Shared Cards</h2><p>Click link to view card, or Trash to delete.</p>";
            overlay.appendChild(header);

            const grid = document.createElement('div');
            grid.style.cssText = "display:grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap:10px; overflow-y:auto; padding:20px 0;";
            overlay.appendChild(grid);

            // Loading state
            grid.innerHTML = '<div style="color:#aaa;">Loading cloud files...</div>';
            document.body.appendChild(overlay);

            // Close button helper
            const addCloseBtn = () => {
                const closeBtn = document.createElement('button');
                closeBtn.innerText = "Close";
                closeBtn.className = 'primary';
                closeBtn.style.cssText = "margin-top:auto; align-self:center; padding:10px 30px;";
                closeBtn.onclick = () => document.body.removeChild(overlay);
                overlay.appendChild(closeBtn);
            };

            try {
                const session = await fetchAuthSession();
                if (!session.tokens) {
                    grid.innerHTML = '<div style="color:#f55;">Please sign in to view shared cards.</div>';
                    addCloseBtn();
                    return;
                }

                const bucket = awsconfig.aws_user_files_s3_bucket;
                const region = awsconfig.aws_user_files_s3_bucket_region;

                const result = await list({
                    options: { accessLevel: 'guest' }
                });

                grid.innerHTML = '';
                if (result.items.length === 0) {
                    grid.innerHTML = '<div style="color:#aaa;">No cards found. Publish one first!</div>';
                }

                result.items.forEach(item => {
                    const itemEl = document.createElement('div');
                    itemEl.style.cssText = "display: flex; justify-content: space-between; align-items: center; background: #333; padding: 15px; border-radius: 8px; border: 1px solid #555; font-size: 1rem;";

                    const nameEl = document.createElement('span');
                    nameEl.innerText = item.key;
                    nameEl.style.cssText = "cursor: pointer; color: var(--accent-color); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex-grow: 1; font-weight:bold;";
                    nameEl.onclick = () => {
                        const url = `https://${bucket}.s3.${region}.amazonaws.com/public/${item.key}`;
                        window.open(url, '_blank');
                    };

                    const delBtn = document.createElement('button');
                    delBtn.innerText = 'üóëÔ∏è';
                    delBtn.style.cssText = "cursor: pointer; margin-left: 10px; background: transparent; border: none; font-size: 1.2rem;";
                    delBtn.onclick = async (e) => {
                        e.stopPropagation();

                        if (delBtn.innerText === 'üóëÔ∏è') {
                            delBtn.innerText = 'Sure?';
                            setTimeout(() => {
                                if (itemEl.parentElement) delBtn.innerText = 'üóëÔ∏è';
                            }, 3000);
                        } else {
                            delBtn.innerText = "‚è≥";
                            try {
                                await remove({ key: item.key, options: { accessLevel: 'guest' } });
                                itemEl.remove();
                            } catch (err) {
                                // alert("Failed to delete: " + err.message);
                                console.error(err);
                                delBtn.innerText = 'üóëÔ∏è';
                            }
                        }
                    };

                    itemEl.appendChild(nameEl);
                    itemEl.appendChild(delBtn);
                    grid.appendChild(itemEl);
                });

            } catch (error) {
                console.error("Error loading gallery:", error);
                grid.innerHTML = '<div style="color:#f55;">Error loading shared cards.</div>';
            }
            addCloseBtn();
        }

        // Mobile UI Logic
        const btnToggleLeft = document.getElementById('btn-toggle-left');
        const btnToggleRight = document.getElementById('btn-toggle-right');
        const backdrop = document.getElementById('mobile-backdrop');
        const panelLeft = document.querySelector('.panel');
        const panelRight = document.querySelector('.panel-right');

        function closeAllPanels() {
            if (panelLeft) panelLeft.classList.remove('open');
            if (panelRight) panelRight.classList.remove('open');
            if (backdrop) backdrop.classList.remove('active');
        }

        if (btnToggleLeft && btnToggleRight && backdrop) {
            btnToggleLeft.onclick = () => {
                const isOpen = panelLeft.classList.contains('open');
                closeAllPanels();
                if (!isOpen) {
                    panelLeft.classList.add('open');
                    backdrop.classList.add('active');
                }
            };

            btnToggleRight.onclick = () => {
                const isOpen = panelRight.classList.contains('open');
                closeAllPanels();
                if (!isOpen) {
                    panelRight.classList.add('open');
                    backdrop.classList.add('active');
                }
            };

            backdrop.onclick = closeAllPanels;
        }

        Hub.listen('auth', ({ payload }) => {
            switch (payload.event) {
                case 'signedIn':
                    console.log('User signed in');
                    break;
                case 'signedOut':
                    break;
            }
        });

        async function generateHTMLString() {
            // Re-use logic from btn-export-html but return string instead of downloading
            const dataOut = canvasOutside.toDataURL('image/jpeg', 0.8);
            const dataIn = canvasInside.toDataURL('image/jpeg', 0.8);

            return getRobustViewerHTML(dataOut, dataIn);
        }

        function showPublishSuccessModal(url) {
            const overlay = document.createElement('div');
            overlay.style.cssText = "position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.85); z-index:10000; display:flex; align-items:center; justify-content:center; font-family:sans-serif;";

            const box = document.createElement('div');
            box.style.cssText = "background:var(--panel-bg); backdrop-filter:blur(10px); padding:30px; border-radius:16px; border:1px solid var(--panel-border); color:white; width:90%; max-width:400px; display:flex; flex-direction:column; gap:15px; box-shadow:0 20px 50px rgba(0,0,0,0.6); text-align:center;";

            box.innerHTML = `
                <div style="font-size:3rem; margin-bottom:-10px;">üéâ</div>
                <h3 style="margin:0; font-size:1.5rem; font-weight:700;">Card Published!</h3>
                <p style="color:#ccc; margin:0; font-size:0.95rem;">Your 3D card is live and ready to share.</p>
                
                <div style="background:rgba(0,0,0,0.3); padding:12px; border-radius:8px; border:1px solid var(--panel-border); word-break:break-all; font-family:monospace; font-size:0.85rem; user-select:all; color:var(--accent-color);">
                    ${url}
                </div>

                <div style="display:flex; flex-direction:column; gap:10px; margin-top:10px;">
                    <button id="btn-copy-link" style="padding:12px; background:var(--accent-color); border:none; color:white; border-radius:10px; cursor:pointer; font-weight:bold; width:100%; font-size:1rem; transition: transform 0.1s;">
                        üìã Copy Link
                    </button>
                    <button id="btn-share-native" style="padding:12px; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.2); color:white; border-radius:10px; cursor:pointer; font-weight:bold; width:100%; font-size:1rem; display:none; transition: background 0.2s;">
                        üì£ Share Card
                    </button>
                </div>

                <button id="btn-close-success" style="padding:10px; background:transparent; border:none; color:#888; cursor:pointer; margin-top:5px; font-size:0.9rem;">Close</button>
            `;

            overlay.appendChild(box);
            document.body.appendChild(overlay);

            const btnCopy = box.querySelector('#btn-copy-link');
            const btnShare = box.querySelector('#btn-share-native');
            const btnClose = box.querySelector('#btn-close-success');

            // Copy Logic
            btnCopy.onclick = () => {
                navigator.clipboard.writeText(url).then(() => {
                    const original = btnCopy.innerHTML;
                    btnCopy.innerHTML = "‚úÖ Copied!";
                    btnCopy.style.background = "#4cd964"; // Green success
                    setTimeout(() => {
                        btnCopy.innerHTML = original;
                        btnCopy.style.background = "var(--accent-color)";
                    }, 2000);
                }).catch(err => {
                    console.error('Failed to copy: ', err);
                    prompt("Copy this link manually:", url);
                });
            };

            // Share Logic
            if (navigator.share) {
                btnShare.style.display = 'block';
                btnShare.onclick = () => {
                    navigator.share({
                        title: 'Greeting Card',
                        text: 'I created a 3D greeting card for you!',
                        url: url
                    }).catch((e) => console.log('Share canceled/failed', e));
                };
            }

            // Close logic
            const close = () => {
                overlay.style.opacity = '0';
                setTimeout(() => document.body.removeChild(overlay), 200);
            };
            overlay.style.transition = 'opacity 0.2s';

            btnClose.onclick = close;
            overlay.onclick = (e) => { if (e.target === overlay) close(); };
        }

        document.getElementById('btn-publish-cloud').onclick = async () => {
            const btn = document.getElementById('btn-publish-cloud');
            const originalText = btn.innerText;
            btn.innerText = "‚è≥ Publishing...";
            btn.disabled = true;

            try {
                // Force session refresh before upload to avoid unauthRole error
                const session = await fetchAuthSession({ forceRefresh: true });
                if (!session.tokens) {
                    throw new Error("You must be signed in to publish to the cloud.");
                }

                const htmlString = await generateHTMLString();
                const key = `card-${Date.now()}.html`;

                await uploadData({
                    key: key,
                    data: htmlString,
                    options: {
                        accessLevel: 'guest',
                        contentType: 'text/html'
                    }
                }).result;

                // alert("Card Published!");

                const bucket = awsconfig.aws_user_files_s3_bucket;
                const region = awsconfig.aws_user_files_s3_bucket_region;
                const url = `https://${bucket}.s3.${region}.amazonaws.com/public/${key}`;

                showPublishSuccessModal(url);

            } catch (error) {
                console.error("Publish error:", error);
                showCustomAlert("Failed to publish card: " + error.message, "Publish Error");
            } finally {
                btn.innerText = originalText;
                btn.disabled = false;
            }
        };

        // --- Render Loop ---
        function animate() {
            requestAnimationFrame(animate);

            // Smooth Rotation for Main Group (Front/Back views)
            if (Math.abs(cardYTarget - mainCardGroup.rotation.y) > 0.001) {
                mainCardGroup.rotation.y += (cardYTarget - mainCardGroup.rotation.y) * 0.05;
            }

            controls.update();

            // Fix for initial load race condition or context loss
            // We force update textures if they haven't been rendered yet
            if (renderer.info.render.frame % 30 === 0) {
                texOutside.needsUpdate = true;
                texInside.needsUpdate = true;
            }

            renderer.render(scene, camera);
        }
        animate();

        // Initial State
        // Add timeout to ensure fonts/images are ready
        setTimeout(() => {
            updateFold(0.2); // 20% Open
            updateContentToolsState(STATE.viewMode); // Disable tools if in orbit
            Canvas2D.render();

            // Initial Camera: Match "Front" view logic but keep angle
            if (camera && controls) {
                // Calculate dynamic safe Z for single panel (5.5 width)
                const safeZ = getSafeZ(5.5);

                // Front view pos is typically (0, 0, safeZ) looking at (0,0,0)
                // We want slightly higher Y for the "Initial" look, but keeping the Z tight.
                camera.position.set(2.75, 5, safeZ);
                controls.target.set(2.75, 0, 0);
                controls.update();
            }
        }, 500);
    </script>
    <div id="amplify-auth-container" class="hidden"
        style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 10000; background: var(--bg-color); padding: 40px; border-radius: 12px; border: 1px solid var(--panel-border); box-shadow: 0 10px 40px rgba(0,0,0,0.8); min-width: 350px;">
        <button id="btn-close-auth"
            style="position: absolute; right: 15px; top: 15px; background: transparent; border: none; font-size: 1.2rem; cursor: pointer; color: #fff;">√ó</button>

        <div id="auth-form-wrapper">
            <h2 id="auth-title" style="margin-bottom: 20px; font-size: 1.2rem; text-align: center;">Sign In</h2>

            <div id="auth-inputs" style="display: flex; flex-direction: column; gap: 15px;">
                <input type="email" id="auth-username" placeholder="Email"
                    style="background: rgba(0,0,0,0.3); border: 1px solid var(--panel-border); color: white; padding: 10px; border-radius: 6px;">
                <input type="password" id="auth-password" placeholder="Password"
                    style="background: rgba(0,0,0,0.3); border: 1px solid var(--panel-border); color: white; padding: 10px; border-radius: 6px;">
                <input type="text" id="auth-code" class="hidden" placeholder="Confirmation Code"
                    style="background: rgba(0,0,0,0.3); border: 1px solid var(--panel-border); color: white; padding: 10px; border-radius: 6px;">
            </div>

            <button id="btn-auth-submit" class="primary" style="width: 100%; margin-top: 20px; padding: 12px;">Sign
                In</button>

            <div id="auth-toggle-wrapper"
                style="margin-top: 15px; text-align: center; font-size: 0.85rem; color: var(--text-sec);">
                <span id="auth-toggle-text">Need an account?</span>
                <span id="auth-toggle-btn"
                    style="color: var(--accent-color); cursor: pointer; margin-left: 5px; font-weight: 500;">Create
                    Account</span>
            </div>

            <div id="auth-message" style="margin-top: 15px; font-size: 0.85rem; text-align: center; color: #ff6b6b;">
            </div>
        </div>
    </div>
    <!-- Shape Modal -->
    <div id="modal-shapes" class="hidden"
        style="position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:5000; display:flex; align-items:center; justify-content:center;">
        <div
            style="background:var(--panel-bg); backdrop-filter:blur(20px); border:1px solid var(--panel-border); padding:20px; border-radius:12px; width:300px;">
            <h3 style="margin-top:0;">Select Shape</h3>
            <div style="display:grid; grid-template-columns: repeat(3, 1fr); gap:10px; margin-bottom:20px;">
                <button class="shape-opt" data-shape="rect" style="height:60px; font-size:2rem;">‚¨õ</button>
                <button class="shape-opt" data-shape="circle" style="height:60px; font-size:2rem;">‚ö´</button>
                <button class="shape-opt" data-shape="triangle" style="height:60px; font-size:2rem;">üî∫</button>
                <button class="shape-opt" data-shape="star" style="height:60px; font-size:2rem;">‚≠ê</button>
                <button class="shape-opt" data-shape="heart" style="height:60px; font-size:2rem;">‚ù§Ô∏è</button>
            </div>
            <button id="btn-close-shapes" style="width:100%;">Cancel</button>
        </div>
    </div>

    <!-- Sticker Modal -->
    <div id="modal-stickers" class="hidden"
        style="position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:5000; display:flex; align-items:center; justify-content:center;">
        <div
            style="background:var(--panel-bg); backdrop-filter:blur(20px); border:1px solid var(--panel-border); padding:20px; border-radius:12px; width:400px; height:500px; display:flex; flex-direction:column;">
            <h3 style="margin-top:0;">Add Sticker</h3>

            <div
                style="display:flex; gap:10px; margin-bottom:15px; border-bottom:1px solid rgba(255,255,255,0.1); padding-bottom:10px;">
                <button id="tab-general" class="view-btn active" style="flex:1;">General</button>
                <button id="tab-upload" class="view-btn" style="flex:1;">Upload</button>
            </div>

            <div id="sticker-content-general"
                style="flex:1; overflow-y:auto; display:grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap:10px;">
                <!-- Populated via JS -->
            </div>

            <div id="sticker-content-upload" class="hidden"
                style="flex:1; display:flex; flex-direction:column; align-items:center; justify-content:center; text-align:center; color:#aaa;">
                <p>Upload your own sticker image (PNG/JPG)</p>
                <input type="file" id="sticker-upload-input" accept="image/*" style="display:block; margin-top:10px;">
                <p style="font-size:0.8rem; margin-top:20px;">Images will be scaled down to fit the card.</p>
            </div>

            <button id="btn-close-stickers" style="margin-top:20px; width:100%;">Close</button>
        </div>
    </div>
    <!-- Camera Modal -->
    <div id="modal-camera" class="hidden">
        <video id="camera-feed" autoplay playsinline muted></video>
        <div id="camera-overlay">
            <div id="camera-guide"></div>
        </div>
        <div class="camera-controls">
            <button id="btn-cam-cancel" class="cam-btn">‚úï</button>
            <button id="btn-cam-capture" class="cam-btn capture"></button>
            <button id="btn-cam-switch" class="cam-btn">üîÑ</button>
        </div>

        <!-- Preview -->
        <div id="camera-preview">
            <img id="preview-img" src="">
            <div class="preview-controls">
                <button id="btn-cam-retake" class="primary" style="background:#555;">Retake</button>
                <button id="btn-cam-use" class="primary">Use Photo</button>
            </div>
        </div>
        <canvas id="camera-canvas" class="hidden"></canvas>
    </div>
</body>

</html>