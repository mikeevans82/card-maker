<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Greeting Card Creator</title>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <!-- Three.js & Dependencies via CDN -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://esm.sh/three@0.160.0",
          "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/",
          "@aws-amplify/core": "https://esm.sh/@aws-amplify/core@6.0.12",
          "aws-amplify": "https://esm.sh/aws-amplify@6.0.12?deps=@aws-amplify/core@6.0.12",
          "aws-amplify/auth": "https://esm.sh/aws-amplify@6.0.12/auth?deps=@aws-amplify/core@6.0.12",
          "aws-amplify/storage": "https://esm.sh/aws-amplify@6.0.12/storage?deps=@aws-amplify/core@6.0.12",
          "aws-amplify/utils": "https://esm.sh/aws-amplify@6.0.12/utils?deps=@aws-amplify/core@6.0.12"
        }
      }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/localforage/1.10.0/localforage.min.js"></script>

    <style>
        :root {
            --bg-color: #121212;
            --panel-bg: rgba(30, 30, 30, 0.7);
            --panel-border: rgba(255, 255, 255, 0.1);
            --accent-color: #646cff;
            --accent-hover: #7b83ff;
            --text-main: #ffffff;
            --text-sec: #aaaaaa;
            --glass-blur: 12px;
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background: radial-gradient(circle at 50% 50%, #2a2a2a 0%, #121212 100%);
            color: var(--text-main);
            width: 100vw;
            height: 100vh;
        }

        #app {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
        }

        /* 3D Viewport */
        #viewport {
            flex-grow: 1;
            position: relative;
        }

        #loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 1000;
        }

        /* Sidebar Panels */
        .panel {
            width: 300px;
            background: var(--panel-bg);
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            border-right: 1px solid var(--panel-border);
            display: flex;
            flex-direction: column;
            padding: 20px;
            box-sizing: border-box;
            z-index: 10;
            transition: transform 0.3s ease;
        }

        .panel-right {
            border-right: none;
            border-left: 1px solid var(--panel-border);
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
        }

        h2,
        h3 {
            margin-top: 0;
            font-weight: 500;
            color: var(--text-main);
        }

        h3 {
            font-size: 1rem;
            color: var(--text-sec);
            margin-top: 1rem;
        }

        /* Controls */
        button {
            background: #333;
            color: white;
            border: 1px solid var(--panel-border);
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            margin-bottom: 8px;
            transition: background 0.2s;
            font-family: inherit;
        }

        button:hover {
            background: #444;
        }

        button.primary {
            background: var(--accent-color);
            border-color: var(--accent-color);
        }

        button.primary:hover {
            background: var(--accent-hover);
        }

        .control-group {
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        label {
            font-size: 0.85rem;
            color: var(--text-sec);
            margin-bottom: 4px;
            display: block;
        }

        input[type="text"],
        input[type="number"],
        select {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--panel-border);
            color: white;
            padding: 8px;
            border-radius: 4px;
            width: 100%;
            box-sizing: border-box;
        }

        /* Asset Grid */
        .asset-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 10px;
            overflow-y: auto;
            flex-grow: 1;
            padding-right: 5px;
        }

        .asset-item {
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            cursor: grab;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid transparent;
        }

        .asset-item:hover {
            border-color: var(--accent-color);
        }

        .asset-item img {
            max-width: 100%;
            max-height: 100%;
            pointer-events: none;
        }

        /* View Mode Toggles */
        .view-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--panel-bg);
            backdrop-filter: blur(var(--glass-blur));
            padding: 10px;
            border-radius: 30px;
            display: flex;
            gap: 10px;
            border: 1px solid var(--panel-border);
            z-index: 20;
        }

        .view-btn {
            background: transparent;
            border: none;
            color: var(--text-sec);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
        }

        .view-btn.active {
            background: var(--accent-color);
            color: white;
        }

        /* Hidden Canvas */
        .offscreen-canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            opacity: 0;
            pointer-events: none;
            z-index: -1;
        }

        /* Animation Range */
        #anim-control {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 20;
            background: var(--panel-bg);
            padding: 8px 16px;
            border-radius: 20px;
            backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--panel-border);
        }

        input[type="range"] {
            accent-color: var(--accent-color);
        }

        .toolbar-icon {
            margin-right: 5px;
        }

        .hidden {
            display: none !important;
        }

        /* File Input hidden */
        #file-input {
            display: none;
        }

        /* Draggable highlight on canvas */
        .drag-over {
            box-shadow: inset 0 0 20px var(--accent-color);
        }
    </style>
</head>

<body>

    <div id="app">
        <!-- Left Sidebar: Assets & Tools -->
        <div class="panel">
            <h2>Card Creator</h2>



            <div class="control-group">
                <h3>Content Tools</h3>
                <button id="btn-add-text">Add Text</button>
                <div style="display:flex; gap:5px;">
                    <button id="btn-add-shape" style="flex:1;">Add Shapes</button>
                    <button id="btn-add-sticker" style="flex:1;">Add Stickers</button>
                </div>
                <button id="btn-import-scan">Import Scanned Card</button>
            </div>





            <div class="control-group">
                <h3>Cards</h3>
                <button id="btn-new-card" style="margin-bottom: 5px;">+ New Card</button>
                <button id="btn-save-project">Save Card</button>
                <button id="btn-load-project">Load Card</button>
                <button id="btn-export-html" class="primary">Download Card</button>
            </div>

            <div class="control-group">
                <h3>Cloud Tools</h3>
                <!-- Auth Status -->
                <div
                    style="margin-bottom: 10px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 6px;">
                    <div id="auth-status" style="font-size: 0.8rem; margin-bottom: 5px; color: #ccc;">Checking...</div>
                    <button id="btn-login-toggle" style="width: 100%; font-size: 0.8rem; padding: 5px;">Sign In</button>
                </div>

                <button id="btn-shared-cards" class="primary">Shared Cards</button>
                <button id="btn-publish-cloud" class="primary" style="background: #e91e63;">☁️ Publish to
                    Cloud</button>
            </div>
        </div>

        <!-- Main Viewport -->
        <div id="viewport">
            <canvas id="three-canvas"></canvas>

            <!-- Top Control: Open/Close -->
            <div id="anim-control">
                <span>Closed</span>
                <input type="range" id="slider-open" min="0" max="1" step="0.01" value="0.5">
                <span>Open</span>
            </div>

            <!-- View Controls (Focus Modes) -->
            <div class="view-controls">
                <button class="view-btn active" data-view="orbit">Free View</button>
                <button class="view-btn" data-view="front">Front</button>
                <button class="view-btn" data-view="inside-left">Inside Left</button>
                <button class="view-btn" data-view="inside-right">Inside Right</button>
                <button class="view-btn" data-view="back">Back</button>
            </div>
        </div>

        <!-- Right Sidebar: Properties (Visible on Selection) -->
        <div class="panel panel-right" id="prop-panel" style="transform: translateX(110%);">
            <h2>Properties</h2>
            <div id="props-content">
                <!-- Dynamic Properties -->
            </div>
            <button id="btn-delete-element" style="background: #a33; margin-top: 20px;">Delete Element</button>
            <button id="btn-close-props" style="margin-top: 10px;">Close</button>
        </div>
    </div>
    </div>

    <div id="loading-overlay">
        <h2>Loading...</h2>
        <p id="loading-msg" style="margin-top:10px; font-size: 0.9rem; color:#aaa;">Connecting to libraries...</p>
    </div>

    <!-- Hidden inputs/canvases -->
    <input type="file" id="file-input-scan-front" accept="image/*">
    <input type="file" id="file-input-scan-back" accept="image/*">
    <div class="offscreen-canvas-container">
        <canvas id="tex-canvas-outside" width="2048" height="1582"></canvas>
        <canvas id="tex-canvas-inside" width="2048" height="1582"></canvas>
    </div>

    <!-- Error Handler -->
    <script>
        setTimeout(() => {
            if (!window.THREE && !document.querySelector('canvas').clientHeight) {
                document.getElementById('loading-msg').innerHTML =
                    "Could not load Three.js.<br>Please check your internet connection and reload.<br>This app requires an internet connection for the first run to cache libraries.";
                document.getElementById('loading-msg').style.color = "#ff6b6b";
            }
        }, 5000);
    </script>

    <script type="module">
        import awsconfig from './aws-exports.js';
        import { Amplify } from 'aws-amplify';
        import { uploadData, list, remove, getUrl } from 'aws-amplify/storage';
        import { getCurrentUser, fetchAuthSession, signIn, signUp, confirmSignUp, autoSignIn, signOut, fetchUserAttributes } from 'aws-amplify/auth';
        import { Hub } from 'aws-amplify/utils';
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        console.log("Configuring Amplify with (flat):", awsconfig);

        try {
            Amplify.configure({
                Auth: {
                    Cognito: {
                        userPoolId: awsconfig.aws_user_pools_id,
                        userPoolClientId: awsconfig.aws_user_pools_web_client_id,
                        identityPoolId: awsconfig.aws_cognito_identity_pool_id,
                        allowGuestAccess: true,
                        // Explicitly set the region for credential verification
                        region: awsconfig.aws_cognito_region,
                        loginWith: {
                            email: true
                        }
                    }
                },
                Storage: {
                    S3: {
                        bucket: awsconfig.aws_user_files_s3_bucket,
                        region: awsconfig.aws_user_files_s3_bucket_region
                    }
                }
            });
            console.log("Amplify v6 configuration successful");
        } catch (e) {
            console.error("Amplify configuration failed:", e);
        }

        // Hide loader
        document.getElementById('loading-overlay').classList.add('hidden');

        // --- State Management ---
        const STATE = {
            cardOpen: 0.5, // 0 to 1
            viewMode: 'orbit', // orbit, front, inside-left, inside-right, back
            selectedElement: null,
            selectedPanel: null, // 'front', 'back', 'inside-left', 'inside-right'
            db: null, // IndexedDB

            // Canvas Data Models
            // Each item: { id, type: 'text'|'image'|'shape', x, y, width, height, rotation, ...props }
            layers: {
                outside: [],
                inside: []
            },

            assets: [] // Loaded images blobs
        };

        /** 
         * Constants
         * Standard Letter: 11in x 8.5in
         * Folded: 5.5in x 8.5in
         * 3D Units: 1 unit = 1 inch
         */
        const DIMS = {
            width: 11,
            height: 8.5,
            panelWidth: 5.5
        };

        // --- 3D Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);

        // Camera
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 10, getSafeZ());

        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-canvas'), antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Lights
        const ambLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(5, 10, 7);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // Global Error Handler for user feedback
        window.onerror = function (msg, url, line) {
            alert("JS Error: " + msg + "\nLine: " + line);
        };

        // --- Card Geometry Setup ---
        // Reformulated for Standard English Opening (Hinge on Left, Front Cover opens L->R).
        // Left Wing = Front Cover + Inside Left.
        // Right Wing = Back Cover + Inside Right.

        const PAPER_THICKNESS = 0.01;
        const P_WIDTH = DIMS.panelWidth; // 5.5
        const P_HEIGHT = DIMS.height;    // 8.5
        const P_CENTER_OFFSET = P_WIDTH / 2; // 2.75

        // Materials (Canvas Textures)
        const canvasOutside = document.getElementById('tex-canvas-outside');
        const canvasInside = document.getElementById('tex-canvas-inside');

        const texOutside = new THREE.CanvasTexture(canvasOutside);
        texOutside.colorSpace = THREE.SRGBColorSpace;
        const texInside = new THREE.CanvasTexture(canvasInside);
        texInside.colorSpace = THREE.SRGBColorSpace;

        // Expose for debug/Canvas2D access
        window.texOutside = texOutside;
        window.texInside = texInside;

        // Use Basic Material with DoubleSide to ensure visibility and Raycast hits
        const matOutside = new THREE.MeshBasicMaterial({ map: texOutside, side: THREE.DoubleSide });
        const matInside = new THREE.MeshBasicMaterial({ map: texInside, side: THREE.DoubleSide });

        // Groups
        const leftWing = new THREE.Group();
        const rightWing = new THREE.Group();

        // Offset Left Wing (Front) forward to fold ON TOP of Right Wing (Back)
        leftWing.position.z = PAPER_THICKNESS * 2;

        scene.add(leftWing);
        scene.add(rightWing);

        // Standard Centered Plane
        const geoBase = new THREE.PlaneGeometry(P_WIDTH, P_HEIGHT);

        // --- Left Wing (Front Cover + Inside Left) ---
        // Pivot at 0. Panel extends -X.

        const leftInsideMesh = new THREE.Mesh(geoBase.clone(), matInside);
        leftInsideMesh.position.set(-P_CENTER_OFFSET, 0, PAPER_THICKNESS);
        setUVs(leftInsideMesh.geometry, 0, 0.5); // Inside Left

        const leftOutsideMesh = new THREE.Mesh(geoBase.clone(), matOutside);
        leftOutsideMesh.position.set(-P_CENTER_OFFSET, 0, -PAPER_THICKNESS);
        leftOutsideMesh.rotation.y = Math.PI;
        // FRONT COVER (Canvas 0.5-1.0).
        // Rot 180. Local Left(-X) is World Right(Spine).
        // Map U0(Edge) -> 1.0. U1(Spine) -> 0.5.
        setUVs(leftOutsideMesh.geometry, 0.5, 1.0); // Fixed Front UVs

        leftWing.add(leftInsideMesh);
        leftWing.add(leftOutsideMesh);

        // --- Right Wing (Back Cover + Inside Right) ---
        // Pivot at 0. Panel extends +X. Stationary.

        const rightInsideMesh = new THREE.Mesh(geoBase.clone(), matInside);
        rightInsideMesh.position.set(P_CENTER_OFFSET, 0, PAPER_THICKNESS);
        setUVs(rightInsideMesh.geometry, 0.5, 1.0); // Inside Right

        const rightOutsideMesh = new THREE.Mesh(geoBase.clone(), matOutside);
        rightOutsideMesh.position.set(P_CENTER_OFFSET, 0, -PAPER_THICKNESS);
        rightOutsideMesh.rotation.y = Math.PI;
        // BACK COVER (Canvas 0.0-0.5).
        // Rot 180. Local Left(-X) is World Right(Edge).
        // Map U0(Spine) -> 0.5. U1(Edge) -> 0.0.
        setUVs(rightOutsideMesh.geometry, 0.0, 0.5); // Fixed Back UVs

        rightWing.add(rightInsideMesh);
        rightWing.add(rightOutsideMesh);


        // --- Helper: UV Mapping ---
        function setUVs(geometry, uMin, uMax) {
            const uvs = geometry.attributes.uv;
            for (let i = 0; i < uvs.count; i++) {
                const u = uvs.getX(i);
                const newU = uMin + u * (uMax - uMin);
                uvs.setX(i, newU);
            }
            uvs.needsUpdate = true;
        }

        // --- Animation & View Logic ---

        // Define targets. 
        // Angle: 0 -> -PI (Right wing folds Over) -> Now Left Wing folds +PI
        const viewPositions = {
            'orbit': { pos: null, look: null },
            'front': {
                pos: new THREE.Vector3(P_CENTER_OFFSET, 0, 15), // Looking at Closed Front (+X)
                look: new THREE.Vector3(P_CENTER_OFFSET, 0, 0)
            },
            'back': {
                pos: new THREE.Vector3(P_CENTER_OFFSET, 0, -15), // Looking at Closed Back (+X)
                look: new THREE.Vector3(P_CENTER_OFFSET, 0, 0)
            },
            'inside-left': {
                pos: new THREE.Vector3(-P_CENTER_OFFSET, 0, 15),
                look: new THREE.Vector3(-P_CENTER_OFFSET, 0, 0)
            },
            'inside-right': {
                pos: new THREE.Vector3(P_CENTER_OFFSET, 0, 15),
                look: new THREE.Vector3(P_CENTER_OFFSET, 0, 0)
            }
        };

        function updateFold(openFactor) {
            // openFactor: 1.0 (Flat Open) -> 0.0 (Closed)
            // Left Wing rotates 0 -> +PI.

            const angle = (1 - openFactor) * Math.PI;
            // Limit slightly to prevent mesh collision if logic fails
            const clampAngle = Math.min(angle, Math.PI - 0.05);

            leftWing.rotation.y = clampAngle;
            STATE.cardOpen = openFactor;
        }

        document.getElementById('slider-open').addEventListener('input', (e) => {
            updateFold(parseFloat(e.target.value));
            if (STATE.viewMode !== 'orbit') return;
        });

        // --- Canvas Drawing Logic ---
        const Canvas2D = {
            ctxOut: canvasOutside.getContext('2d'),
            ctxIn: canvasInside.getContext('2d'),
            width: 2048,
            height: 1582,

            // Redraw entire canvas from state
            render: function () {
                console.log("Canvas2D: Rendering...");
                try {
                    this.clear(this.ctxOut);
                    this.clear(this.ctxIn);

                    // Draw backgrounds (White paper)
                    this.ctxOut.fillStyle = '#ffffff';
                    this.ctxOut.fillRect(0, 0, this.width, this.height);

                    this.ctxIn.fillStyle = '#ffffff';
                    this.ctxIn.fillRect(0, 0, this.width, this.height);

                    // Draw guide link (fold)
                    this.drawGuide(this.ctxOut);
                    this.drawGuide(this.ctxIn);

                    // Render Layers
                    if (STATE.layers) {
                        STATE.layers.outside.forEach(l => this.drawLayer(this.ctxOut, l));
                        STATE.layers.inside.forEach(l => this.drawLayer(this.ctxIn, l));
                    }

                    // Update Textures
                    if (window.texOutside) texOutside.needsUpdate = true;
                    if (window.texInside) texInside.needsUpdate = true;

                } catch (e) {
                    console.error("Canvas Render Error", e);
                    alert("Canvas Render Error: " + e.message);
                }
            },

            clear: function (ctx) {
                ctx.clearRect(0, 0, this.width, this.height);
            },

            drawGuide: function (ctx) {
                ctx.strokeStyle = '#eee';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.width / 2, 0);
                ctx.lineTo(this.width / 2, this.height);
                ctx.stroke();
            },

            drawLayer: function (ctx, layer) {
                ctx.save();
                ctx.translate(layer.x, layer.y);
                ctx.rotate(layer.rotation || 0);

                if (layer === STATE.selectedElement) {
                    // Highlight selection
                    ctx.strokeStyle = '#646cff';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(-layer.width / 2 - 2, -layer.height / 2 - 2, layer.width + 4, layer.height + 4);
                }

                if (layer.type === 'text') {
                    ctx.font = `${layer.bold ? 'bold ' : ''}${layer.fontSize}px ${layer.fontFamily}`;
                    ctx.fillStyle = layer.color;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(layer.text, 0, 0);
                } else if (layer.type === 'image') {
                    if (layer.imgElement) {
                        ctx.drawImage(layer.imgElement, -layer.width / 2, -layer.height / 2, layer.width, layer.height);
                    }

                } else if (layer.type === 'shape') {
                    ctx.fillStyle = layer.color;
                    ctx.beginPath();
                    const w = layer.width;
                    const h = layer.height;
                    const hw = w / 2;
                    const hh = h / 2;

                    if (layer.subtype === 'rect') {
                        ctx.fillRect(-hw, -hh, w, h);
                    } else if (layer.subtype === 'circle') {
                        ctx.ellipse(0, 0, Math.abs(hw), Math.abs(hh), 0, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (layer.subtype === 'triangle') {
                        ctx.moveTo(0, -hh);
                        ctx.lineTo(hw, hh);
                        ctx.lineTo(-hw, hh);
                        ctx.closePath();
                        ctx.fill();
                    } else if (layer.subtype === 'star') {
                        // 5-point star
                        const outer = Math.min(w, h) / 2;
                        const inner = outer * 0.4;
                        for (let i = 0; i < 10; i++) {
                            const r = (i % 2 === 0) ? outer : inner;
                            const a = Math.PI / 2 + i * Math.PI / 5; // Start top
                            const sx = Math.cos(a) * r; // rotated -90deg?
                            // Fix rotation to point up:
                            // i=0 is outer top.
                            const ang = -Math.PI / 2 + i * (Math.PI / 5);
                            const x = Math.cos(ang) * r;
                            const y = Math.sin(ang) * r;
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.closePath();
                        ctx.fill();
                    } else if (layer.subtype === 'heart') {
                        const topCurveHeight = h * 0.3;
                        ctx.moveTo(0, -hh + topCurveHeight);
                        // Top left curve
                        ctx.bezierCurveTo(
                            -w / 2, -hh,
                            -w, -hh + topCurveHeight,
                            0, hh
                        );
                        // Top right curve
                        ctx.bezierCurveTo(
                            w, -hh + topCurveHeight,
                            w / 2, -hh,
                            0, -hh + topCurveHeight
                        );
                        ctx.fill();
                    } else {
                        // Fallback rect
                        ctx.fillRect(-hw, -hh, w, h);
                    }
                }

                ctx.restore();
            }
        };

        // --- Interaction / Raycaster Logic ---
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let initialElemPos = { x: 0, y: 0 };

        function onPointerMove(event) {
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

            if (isDragging && STATE.selectedElement && STATE.viewMode !== 'orbit') {
                if (!STATE.selectedElement.locked) {
                    handleDrag();
                }
            }
        }
        function getCanvasCoords(hit) {
            const uv = hit.uv;
            let cx = uv.x * Canvas2D.width;
            const cy = (1 - uv.y) * Canvas2D.height;

            // Standard mapping ensures correct Drag Direction (Left moves Left).
            // Offset (-250) compensates for visual misalignment where click target 
            // is effectively shifted right relative to visual position.

            cx -= 250;


            return { x: cx, y: cy };
        }

        function handleDrag() {
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects([leftInsideMesh, rightInsideMesh, leftOutsideMesh, rightOutsideMesh]);

            if (intersects.length > 0) {
                const pos = getCanvasCoords(intersects[0]);
                STATE.selectedElement.x = pos.x;
                STATE.selectedElement.y = pos.y;
                Canvas2D.render();
            }
        }

        function onPointerDown(event) {
            // Ignore clicks on UI elements (panels, buttons, inputs)
            if (event.target !== renderer.domElement) return;

            if (STATE.viewMode === 'orbit') return;

            raycaster.setFromCamera(pointer, camera);
            const targets = [];
            if (STATE.viewMode === 'front' || STATE.viewMode === 'back') {
                targets.push(leftOutsideMesh, rightOutsideMesh);
            } else {
                targets.push(leftInsideMesh, rightInsideMesh);
            }

            const intersects = raycaster.intersectObjects(targets);

            if (intersects.length > 0) {
                const hit = intersects[0];
                const pos = getCanvasCoords(hit);
                const cx = pos.x;
                const cy = pos.y;

                // Determine active canvas (Inside or Outside)
                const isInside = (hit.object === leftInsideMesh || hit.object === rightInsideMesh);
                const list = isInside ? STATE.layers.inside : STATE.layers.outside;

                // Find clicked element (reverse order for z-index)
                let found = null;
                for (let i = list.length - 1; i >= 0; i--) {
                    const el = list[i];
                    // Simple box check with padding
                    const padding = 25;
                    if (Math.abs(cx - el.x) < (el.width / 2 + padding) && Math.abs(cy - el.y) < (el.height / 2 + padding)) {
                        found = el;
                        break;
                    }
                }

                if (found) {
                    STATE.selectedElement = found;
                    // Only start drag if not locked
                    if (!found.locked) {
                        isDragging = true;
                    }
                    controls.enabled = false;
                    showProperties(found);
                    Canvas2D.render();
                } else {
                    STATE.selectedElement = null;
                    document.getElementById('prop-panel').style.transform = 'translateX(110%)';
                    Canvas2D.render();
                }
            }
        }

        function onPointerUp() {
            isDragging = false;
            if (STATE.viewMode === 'orbit') controls.enabled = true;
        }

        window.addEventListener('pointermove', onPointerMove);
        window.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('pointerup', onPointerUp);
        window.addEventListener('resize', onWindowResize);

        function onWindowResize() {
            const w = window.innerWidth;
            const h = window.innerHeight;

            camera.aspect = w / h;
            camera.updateProjectionMatrix();
            renderer.setSize(w, h);

            const safeZ = getSafeZ();
            const sign = (camera.position.z >= 0) ? 1 : -1;

            if (STATE.viewMode === 'orbit') {
                camera.position.z = safeZ * sign;
            } else {
                const targetPos = camera.position.clone();
                targetPos.z = safeZ * sign;
                animateCamera(targetPos, controls.target.clone());
            }
        }

        function getSafeZ() {
            const aspect = window.innerWidth / window.innerHeight;
            const vFov = camera.fov * (Math.PI / 180);

            // Height fit: Card is 8.5 high. Let's provide some padding (10).
            // Width fit: Card is 11 wide (open). Let's provide padding (13).

            const heightFit = 5.0 / Math.tan(vFov / 2);
            const widthFit = 6.5 / (Math.tan(vFov / 2) * aspect);

            return Math.max(15, heightFit, widthFit);
        }

        // --- View Modes ---
        // viewPositions is defined above in the geometry section

        document.querySelectorAll('.view-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const mode = btn.dataset.view;
                setMode(mode);
            });
        });

        function setMode(mode) {
            STATE.viewMode = mode;
            document.querySelectorAll('.view-btn').forEach(b => {
                if (b.dataset.view) b.classList.remove('active');
            });
            const activeBtn = document.querySelector(`.view-btn[data-view="${mode}"]`);
            if (activeBtn) activeBtn.classList.add('active');

            if (mode === 'orbit') {
                controls.enabled = true;
                // Tween camera back to default
                const safeZ = getSafeZ();
                animateCamera(new THREE.Vector3(0, 10, safeZ), new THREE.Vector3(0, 0, 0));
                return;
            }

            controls.enabled = false;

            // Auto-open/close card based on view
            if (mode === 'front') {
                gsapLikeFold(0);
            } else if (mode === 'back') {
                gsapLikeFold(0);
            } else {
                gsapLikeFold(1);
            }

            const t = viewPositions[mode];
            if (t) {
                const safeZ = getSafeZ();
                const targetPos = t.pos.clone();
                // Preserve sign
                const sign = targetPos.z >= 0 ? 1 : -1;
                targetPos.z = safeZ * sign;

                animateCamera(targetPos, t.look);
            }
        }

        function animateCamera(targetPos, targetLook) {
            const startPos = camera.position.clone();
            const startLook = controls.target.clone();

            let t = 0;
            const duration = 1000; // ms
            const start = performance.now();

            function tick(now) {
                const elapsed = now - start;
                t = Math.min(elapsed / duration, 1);
                // EaseInOutQuad
                const ease = t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;

                camera.position.lerpVectors(startPos, targetPos, ease);
                controls.target.lerpVectors(startLook, targetLook, ease);
                controls.update(); // important

                if (t < 1) requestAnimationFrame(tick);
            }
            requestAnimationFrame(tick);
        }

        function gsapLikeFold(targetVal) {
            const startVal = STATE.cardOpen;
            let t = 0;
            const duration = 800;
            const start = performance.now();

            function tick(now) {
                const elapsed = now - start;
                t = Math.min(elapsed / duration, 1);
                const ease = t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;

                const val = startVal + (targetVal - startVal) * ease;
                updateFold(val);
                document.getElementById('slider-open').value = val;

                if (t < 1) requestAnimationFrame(tick);
            }
            requestAnimationFrame(tick);
        }

        // --- Tool Logic ---
        function addText() {
            // Auto-switch to Front view if in Orbit, to make it easier for user
            if (STATE.viewMode === 'orbit') {
                setMode('front');
            }

            // Allow transition time if we just switched
            setTimeout(() => {
                const isInside = STATE.viewMode.includes('inside');
                const list = isInside ? STATE.layers.inside : STATE.layers.outside;

                // Determine center based on current view
                let x = isInside ? (STATE.viewMode === 'inside-right' ? Canvas2D.width * 0.75 : Canvas2D.width * 0.25)
                    : (STATE.viewMode === 'front' ? Canvas2D.width * 0.75 : Canvas2D.width * 0.25);

                const newItem = {
                    id: Date.now(),
                    type: 'text',
                    text: 'New Text',
                    x: x,
                    y: Canvas2D.height / 2,
                    fontSize: 60,
                    fontFamily: 'Inter',
                    color: '#000000',
                    bold: false,
                    rotation: 0,
                    width: 0, height: 0
                };

                // Approx dimensions
                const ctx = isInside ? Canvas2D.ctxIn : Canvas2D.ctxOut;
                ctx.font = `60px Inter`;
                const m = ctx.measureText(newItem.text);
                newItem.width = m.width;
                newItem.height = 60;

                list.push(newItem);
                STATE.selectedElement = newItem;
                Canvas2D.render();
                showProperties(newItem);
            }, 100);
        }

        document.getElementById('btn-add-text').onclick = addText;

        function addRect() {
            if (STATE.viewMode === 'orbit') {
                setMode('front');
            }
            setTimeout(() => {
                const isInside = STATE.viewMode.includes('inside');
                const list = isInside ? STATE.layers.inside : STATE.layers.outside;

                // Determine center
                let x = isInside ? (STATE.viewMode === 'inside-right' ? Canvas2D.width * 0.75 : Canvas2D.width * 0.25)
                    : (STATE.viewMode === 'front' ? Canvas2D.width * 0.75 : Canvas2D.width * 0.25);

                const newItem = {
                    id: Date.now(),
                    type: 'rect',
                    x: x,
                    y: Canvas2D.height / 2,
                    width: 200,
                    height: 100,
                    rotation: 0,
                    color: '#ff0000'
                };

                list.push(newItem);
                STATE.selectedElement = newItem;
                Canvas2D.render();
                showProperties(newItem);
            }, 100);
        }
        // document.getElementById('btn-add-rect').onclick = addRect; // Removed

        // --- Shape UI ---
        document.getElementById('btn-add-shape').onclick = () => {
            const modal = document.getElementById('modal-shapes');
            modal.classList.remove('hidden');
        };
        document.getElementById('btn-close-shapes').onclick = () => {
            document.getElementById('modal-shapes').classList.add('hidden');
        };

        document.querySelectorAll('.shape-opt').forEach(btn => {
            btn.onclick = () => {
                const subtype = btn.dataset.shape;
                addShape(subtype);
                document.getElementById('modal-shapes').classList.add('hidden');
            };
        });

        function addShape(subtype) {
            if (STATE.viewMode === 'orbit') setMode('front');
            setTimeout(() => {
                const isInside = STATE.viewMode.includes('inside');
                const list = isInside ? STATE.layers.inside : STATE.layers.outside;
                const x = isInside ? (STATE.viewMode === 'inside-right' ? Canvas2D.width * 0.75 : Canvas2D.width * 0.25)
                    : (STATE.viewMode === 'front' ? Canvas2D.width * 0.75 : Canvas2D.width * 0.25);

                let w = 200, h = 200;
                let color = '#ff0000';
                if (subtype === 'star') color = '#ffd700';
                if (subtype === 'heart') color = '#ff69b4';
                if (subtype === 'triangle') { w = 200; h = 174; }

                const newItem = {
                    id: Date.now(),
                    type: 'shape',
                    subtype: subtype,
                    x: x,
                    y: Canvas2D.height / 2,
                    width: w,
                    height: h,
                    rotation: 0,
                    color: color
                };

                list.push(newItem);
                STATE.selectedElement = newItem;
                Canvas2D.render();
                showProperties(newItem);
            }, 100);
        }


        // --- Sticker UI ---
        document.getElementById('btn-add-sticker').onclick = () => {
            document.getElementById('modal-stickers').classList.remove('hidden');
        };
        document.getElementById('btn-close-stickers').onclick = () => {
            document.getElementById('modal-stickers').classList.add('hidden');
        };

        // Tabs
        const tabGeneral = document.getElementById('tab-general');
        const tabUpload = document.getElementById('tab-upload');
        const contentGeneral = document.getElementById('sticker-content-general');
        const contentUpload = document.getElementById('sticker-content-upload');

        tabGeneral.onclick = () => {
            tabGeneral.classList.add('active'); tabUpload.classList.remove('active');
            contentGeneral.classList.remove('hidden'); contentUpload.classList.add('hidden');
        };
        tabUpload.onclick = () => {
            tabUpload.classList.add('active'); tabGeneral.classList.remove('active');
            contentUpload.classList.remove('hidden'); contentGeneral.classList.add('hidden');
        };

        // Sticker Upload Logic
        document.getElementById('sticker-upload-input').onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (evt) => {
                addStickerImage(evt.target.result);
                document.getElementById('modal-stickers').classList.add('hidden');
            };
            reader.readAsDataURL(file);
        };

        function addStickerImage(src) {
            // Do NOT change view mode. 
            // If in orbit, we default to placing on Front Cover (Outside Right).
            const img = new Image();
            img.onload = () => {
                // Logic to scale down if too big
                const MAX_SIZE = 500; // 500px is roughly 1/4 of card width 2048
                let w = img.width;
                let h = img.height;

                if (w > MAX_SIZE || h > MAX_SIZE) {
                    const ratio = w / h;
                    if (w > h) {
                        w = MAX_SIZE;
                        h = w / ratio;
                    } else {
                        h = MAX_SIZE;
                        w = h * ratio;
                    }
                }

                const vm = STATE.viewMode || 'front';
                const isInside = vm.includes('inside');
                const list = isInside ? STATE.layers.inside : STATE.layers.outside;

                // Center in view based on the CURRENT vm
                let xPct = 0.75; // Default to Right side (Front / Inside Right)

                if (vm === 'back' || vm === 'inside-left') {
                    xPct = 0.25; // Left side
                }

                const x = Canvas2D.width * xPct;

                list.push({
                    id: Date.now(),
                    type: 'image',
                    imgElement: img,
                    src: src, // Base64 or URL
                    x: x, y: Canvas2D.height / 2,
                    width: w, height: h,
                    rotation: 0
                });
                Canvas2D.render();
            };
            img.src = src;
        }

        // populate general stickers
        const generalGrid = document.getElementById('sticker-content-general');
        const sheetUrl = 'src/assets/stickers/stickers_1.png';

        // Approximate coordinates for the 10 stickers in the generated sheet (1:2 aspect ratio)
        // Adjust these based on the actual generated image layout.
        // Assuming a 2-row layout or similar based on generation prompt.
        // For a robust system, we would use individual files. 
        // Here we slice the sheet on the fly to Data URIs.

        const STICKER_COORDS = [
            { name: 'Cat', x: 29, y: 253, w: 214, h: 231 },
            { name: 'Unicorn', x: 240, y: 240, w: 190, h: 247 },
            { name: 'Cake', x: 429, y: 240, w: 182, h: 231 },
            { name: 'Heart', x: 629, y: 282, w: 186, h: 180 },
            { name: 'Star', x: 820, y: 284, w: 188, h: 185 },

            { name: 'Rainbow', x: 20, y: 546, w: 214, h: 210 },
            { name: 'Flower', x: 263, y: 538, w: 157, h: 240 },
            { name: 'Cupcake', x: 432, y: 546, w: 189, h: 218 },
            { name: 'Smiley', x: 628, y: 556, w: 175, h: 193 },
            { name: 'Paw', x: 825, y: 565, w: 179, h: 180 },
        ];

        const sheetImg = new Image();
        sheetImg.crossOrigin = "Anonymous";
        sheetImg.onload = () => {
            STICKER_COORDS.forEach(coord => {
                // Slice
                const c = document.createElement('canvas');
                c.width = coord.w;
                c.height = coord.h;
                const bx = c.getContext('2d');
                bx.drawImage(sheetImg, coord.x, coord.y, coord.w, coord.h, 0, 0, coord.w, coord.h);
                const dataUrl = c.toDataURL(); // extract sticker

                // UI Item
                const wrapper = document.createElement('div');
                wrapper.className = 'asset-item';
                wrapper.style.cssText = "background: rgba(255,255,255,0.1); cursor: pointer; padding: 5px; border-radius: 4px; display: flex; align-items: center; justify-content: center;";

                const thumb = document.createElement('img');
                thumb.src = dataUrl;
                thumb.style.cssText = "max-width: 100%; max-height: 100%; object-fit: contain; pointer-events: none;";

                wrapper.onclick = () => {
                    addStickerImage(dataUrl);
                    document.getElementById('modal-stickers').classList.add('hidden');
                };

                wrapper.appendChild(thumb);
                generalGrid.appendChild(wrapper);
            });
        };
        sheetImg.src = sheetUrl;

        // --- Properties Panel ---
        function showProperties(item) {
            const p = document.getElementById('prop-panel');
            const content = document.getElementById('props-content');
            content.innerHTML = '';

            p.style.transform = 'translateX(0)';

            // Common props
            content.appendChild(createPropCheckbox('Locked', item.locked || false, v => { item.locked = v; }));
            content.appendChild(createPropInput('X Position', item.x, v => { item.x = parseInt(v); Canvas2D.render(); }));
            content.appendChild(createPropInput('Y Position', item.y, v => { item.y = parseInt(v); Canvas2D.render(); }));

            if (item.type === 'text') {
                content.appendChild(createPropText('Content', item.text, v => {
                    item.text = v;
                    // Recalc width
                    const ctx = Canvas2D.ctxOut; // dummy
                    ctx.font = `${item.bold ? 'bold ' : ''}${item.fontSize}px ${item.fontFamily}`;
                    item.width = ctx.measureText(v).width;
                    Canvas2D.render();
                }));
                content.appendChild(createPropInput('Font Size', item.fontSize, v => {
                    item.fontSize = parseInt(v);
                    item.height = parseInt(v); // approx
                    Canvas2D.render();
                }));
                content.appendChild(createPropColor('Color', item.color, v => { item.color = v; Canvas2D.render(); }));
                content.appendChild(createPropColor('Color', item.color, v => { item.color = v; Canvas2D.render(); }));
            } else if (item.type === 'shape') {
                content.appendChild(createPropInput('Width', item.width, v => { item.width = parseInt(v); Canvas2D.render(); }));
                content.appendChild(createPropInput('Height', item.height, v => { item.height = parseInt(v); Canvas2D.render(); }));
                content.appendChild(createPropColor('Color', item.color, v => { item.color = v; Canvas2D.render(); }));
            }
        }

        function createPropInput(label, val, onChange) {
            const div = document.createElement('div');
            div.className = 'control-group';
            div.innerHTML = `<label>${label}</label><input type="number" value="${val}">`;
            div.querySelector('input').oninput = (e) => onChange(e.target.value);
            return div;
        }

        function createPropText(label, val, onChange) {
            const div = document.createElement('div');
            div.className = 'control-group';
            div.innerHTML = `<label>${label}</label><input type="text" value="${val}">`;
            div.querySelector('input').oninput = (e) => onChange(e.target.value);
            return div;
        }

        function createPropColor(label, val, onChange) {
            const div = document.createElement('div');
            div.className = 'control-group';
            div.innerHTML = `<label>${label}</label><input type="color" value="${val}" style="width:100%; height:30px;">`;
            div.querySelector('input').oninput = (e) => onChange(e.target.value);
            return div;
        }

        function createPropCheckbox(label, val, onChange) {
            const div = document.createElement('div');
            div.className = 'control-group';
            div.style.cssText = "flex-direction: row; align-items: center; justify-content: space-between;";
            div.innerHTML = `<label>${label}</label><input type="checkbox" ${val ? 'checked' : ''}>`;
            div.querySelector('input').onchange = (e) => onChange(e.target.checked);
            return div;
        }

        document.getElementById('btn-close-props').onclick = () => {
            document.getElementById('prop-panel').style.transform = 'translateX(110%)';
            STATE.selectedElement = null;
            Canvas2D.render();
            if (STATE.viewMode === 'orbit') controls.enabled = true;
        };

        document.getElementById('btn-delete-element').onclick = () => {
            if (!STATE.selectedElement) return;
            STATE.layers.outside = STATE.layers.outside.filter(i => i !== STATE.selectedElement);
            STATE.layers.inside = STATE.layers.inside.filter(i => i !== STATE.selectedElement);
            STATE.selectedElement = null;
            Canvas2D.render();
            document.getElementById('btn-close-props').click();
        };




        // Drop on Canvas
        window.addEventListener('dragover', e => e.preventDefault());
        window.addEventListener('drop', (e) => {
            e.preventDefault();

            // This is a global drop, we need to Raycast to see where it lands OR if view is locked, just place.
            if (STATE.draggedImageSrc && STATE.viewMode !== 'orbit') {
                const isInside = STATE.viewMode.includes('inside');
                const list = isInside ? STATE.layers.inside : STATE.layers.outside;

                const img = new Image();
                img.src = STATE.draggedImageSrc;
                img.onload = () => {
                    // Calculate drop pos relative to canvas
                    // Simple assumption: Center of screen / view for now if precise raycasting of drag event is hard without dragover monitoring
                    let x = isInside ? (STATE.viewMode === 'inside-right' ? Canvas2D.width * 0.75 : Canvas2D.width * 0.25)
                        : (STATE.viewMode === 'front' ? Canvas2D.width * 0.75 : Canvas2D.width * 0.25);

                    const ratio = img.width / img.height;
                    const h = 400;
                    const w = h * ratio;

                    list.push({
                        id: Date.now(),
                        type: 'image',
                        imgElement: img,
                        src: STATE.draggedImageB64 || STATE.draggedImageSrc,
                        x: x, y: Canvas2D.height / 2,
                        width: w, height: h,
                        rotation: 0
                    });
                    Canvas2D.render();
                };
            }
        });

        // Import Scanned Card
        document.getElementById('btn-import-scan').onclick = () => {
            // Step 1: Front
            // Step 2: Back
            alert("Please select the image for the FRONT/BACK (Outside) of the paper.");
            document.getElementById('file-input-scan-front').click();
        };

        document.getElementById('file-input-scan-front').onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (evt) => {
                const img = new Image();
                img.onload = () => {
                    STATE.layers.outside = [{
                        id: 'scan-out', type: 'image', imgElement: img,
                        src: evt.target.result, // Persist data
                        x: Canvas2D.width / 2, y: Canvas2D.height / 2,
                        width: Canvas2D.width, height: Canvas2D.height,
                        locked: true
                    }];
                    Canvas2D.render();

                    e.target.value = ''; // Reset for re-use

                    // Chain next
                    // Browser Security: Cannot open file picker from async callback without user gesture.
                    // Show a transient "Next Step" button to capture a new user click.
                    const nextBtn = document.createElement('button');
                    nextBtn.innerText = "Click to Upload INSIDE Image (Step 2/2)";
                    nextBtn.style.cssText = "position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); z-index:9999; padding:20px; font-size:1.2rem; cursor:pointer; background:var(--accent-color); color:white; border:none; border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.5);";

                    document.body.appendChild(nextBtn);

                    nextBtn.onclick = () => {
                        document.body.removeChild(nextBtn);
                        document.getElementById('file-input-scan-back').click();
                    };
                };
                img.onerror = () => alert("Failed to load Front image.");
                img.src = evt.target.result;
            };
            reader.readAsDataURL(file);
        };

        document.getElementById('file-input-scan-back').onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (evt) => {
                const img = new Image();
                img.onload = () => {
                    STATE.layers.inside = [{
                        id: 'scan-in', type: 'image', imgElement: img,
                        src: evt.target.result, // Persist data
                        x: Canvas2D.width / 2, y: Canvas2D.height / 2,
                        width: Canvas2D.width, height: Canvas2D.height,
                        locked: true
                    }];
                    Canvas2D.render();
                    e.target.value = ''; // Reset
                };
                img.onerror = () => alert("Failed to load Inside image.");
                img.src = evt.target.result;
            };
            reader.readAsDataURL(file);
        };


        // --- Export / Persistence Logic ---
        // Helper to rebuild layers with images
        async function hydrateLayers(layers) {
            const hydrated = [];
            for (let l of layers) {
                const item = { ...l };
                if (item.type === 'image' && item.src) {
                    await new Promise((resolve) => {
                        const img = new Image();
                        img.onload = () => resolve();
                        img.onerror = () => resolve();
                        img.src = item.src;
                        item.imgElement = img;
                    });
                }
                hydrated.push(item);
            }
            return hydrated;
        }

        async function renderCardToDataUrls(outsideLayers, insideLayers) {
            const lOut = await hydrateLayers(outsideLayers);
            const lIn = await hydrateLayers(insideLayers);

            const cOut = document.createElement('canvas');
            cOut.width = Canvas2D.width;
            cOut.height = Canvas2D.height;
            const ctxOut = cOut.getContext('2d');

            const cIn = document.createElement('canvas');
            cIn.width = Canvas2D.width;
            cIn.height = Canvas2D.height;
            const ctxIn = cIn.getContext('2d');

            ctxOut.fillStyle = '#ffffff';
            ctxOut.fillRect(0, 0, cOut.width, cOut.height);
            ctxIn.fillStyle = '#ffffff';
            ctxIn.fillRect(0, 0, cIn.width, cIn.height);

            Canvas2D.drawGuide(ctxOut);
            Canvas2D.drawGuide(ctxIn);

            lOut.forEach(l => Canvas2D.drawLayer(ctxOut, l));
            lIn.forEach(l => Canvas2D.drawLayer(ctxIn, l));

            return {
                dataOut: cOut.toDataURL('image/jpeg', 0.8),
                dataIn: cIn.toDataURL('image/jpeg', 0.8)
            };
        }

        function getViewerHTML(dataOut, dataIn) {
            return `<!DOCTYPE html>
<html>
<head>
    <title>You've received a card!</title>
    <style>
        body{margin:0;overflow:hidden;background:#222;}
        .controls { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 100; display: flex; gap: 10px; }
        .controls button { background: rgba(0,0,0,0.6); color: white; border: 1px solid rgba(255,255,255,0.4); padding: 8px 16px; border-radius: 20px; cursor: pointer; font-family: sans-serif; font-size: 14px; transition: background 0.2s; }
        .controls button:hover { background: rgba(255,255,255,0.2); }
    </style>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"><\/script>
    <script type="importmap">{"imports":{"three":"https://unpkg.com/three@0.160.0/build/three.module.js"}}<\/script>
</head>
<body>
<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 100);
    
    // Renderer
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // Responsive Logic
    function onWindowResize() {
        const w = window.innerWidth, h = window.innerHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
        
        const aspect = w / h;
        const vFov = camera.fov * (Math.PI / 180);
        const fitH = 5.0 / Math.tan(vFov / 2); // 8.5 height + padding
        const fitW = 6.5 / (Math.tan(vFov / 2) * aspect); // 11 width + padding
        const safeZ = Math.max(12, fitH, fitW);
        camera.position.z = safeZ;
        camera.position.y = 5; // Look down slightly
    }
    window.addEventListener('resize', onWindowResize);
    onWindowResize(); // Init position
    
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dl = new THREE.DirectionalLight(0xffffff, 0.8); dl.position.set(5,10,7); scene.add(dl);

    // Geometry
    const w=5.5, h=8.5;
    const gBase = new THREE.PlaneGeometry(w, h); // Base geometry
    const THICKNESS = 0.01;
    const OFFSET = w/2;

    // Materials
    const texOut = new THREE.TextureLoader().load('${dataOut}');
    const texIn = new THREE.TextureLoader().load('${dataIn}');
    texOut.colorSpace = THREE.SRGBColorSpace;
    texIn.colorSpace = THREE.SRGBColorSpace;
    
    const matOut = new THREE.MeshBasicMaterial({map:texOut, side:THREE.FrontSide});
    const matIn = new THREE.MeshBasicMaterial({map:texIn, side:THREE.FrontSide});

    const cardWrapper = new THREE.Group();
    scene.add(cardWrapper);

    const leftGroup = new THREE.Group();
    const rightGroup = new THREE.Group();
    // Front wing (Left) sits on top of Back wing (Right)
    leftGroup.position.z = THICKNESS * 2; 

    cardWrapper.add(leftGroup);
    cardWrapper.add(rightGroup);
    
    // Helper
    function setUVs(geo, min, max) {
        const uvs = geo.attributes.uv;
        for(let i=0; i<uvs.count; i++){
            let u = uvs.getX(i);
            u = min + u * (max - min);
            uvs.setX(i, u);
        }
    }

    // Left Wing (Front Cover + Inside Left)
    const lIn = new THREE.Mesh(gBase.clone(), matIn); 
    lIn.position.set(-OFFSET, 0, THICKNESS);
    setUVs(lIn.geometry, 0, 0.5); // Inside Left
    leftGroup.add(lIn);
    
    const lOut = new THREE.Mesh(gBase.clone(), matOut); 
    lOut.position.set(-OFFSET, 0, -THICKNESS);
    lOut.rotation.y = Math.PI; 
    setUVs(lOut.geometry, 0.5, 1.0); // Fixed Front
    leftGroup.add(lOut);

    // Right Wing (Back Cover + Inside Right)
    const rIn = new THREE.Mesh(gBase.clone(), matIn); 
    rIn.position.set(OFFSET, 0, THICKNESS);
    setUVs(rIn.geometry, 0.5, 1.0);
    rightGroup.add(rIn);
    
    const rOut = new THREE.Mesh(gBase.clone(), matOut); 
    rOut.position.set(OFFSET, 0, -THICKNESS);
    rOut.rotation.y = Math.PI; 
    setUVs(rOut.geometry, 0.0, 0.5); // Fixed Back
    rightGroup.add(rOut);
    
    // Interaction State
    const CLOSED_ANGLE = Math.PI * 0.9; // 90% Closed
    const OPEN_ANGLE = Math.PI * 0.1;   // 90% Open
    let targetAngle = CLOSED_ANGLE; 
    leftGroup.rotation.y = CLOSED_ANGLE;

    let isDragging = false;
    document.addEventListener('mousedown', () => isDragging = false);
    document.addEventListener('mousemove', () => isDragging = true);
    document.addEventListener('mouseup', (e) => {
        if (e.target.closest && e.target.closest('.controls')) return;
        if (!isDragging) {
             targetAngle = (targetAngle === CLOSED_ANGLE) ? OPEN_ANGLE : CLOSED_ANGLE;
        }
    });

    function animate() {
        requestAnimationFrame(animate);
        // Smooth Lerp
        leftGroup.rotation.y += (targetAngle - leftGroup.rotation.y) * 0.05;
        controls.update();
        renderer.render(scene, camera);
    }
    animate();

    // UI Logic
    document.getElementById('btn-open').onclick = () => targetAngle = OPEN_ANGLE;
    document.getElementById('btn-close').onclick = () => targetAngle = CLOSED_ANGLE;
    
    document.getElementById('btn-front').onclick = () => {
        // Reset orbit
        controls.reset();
        camera.position.set(0, 0, 15);
        camera.lookAt(0,0,0);
        onWindowResize(); // Recalc safe Z
    };
    
    document.getElementById('btn-back').onclick = () => {
        controls.reset();
        camera.position.set(0, 0, -15);
        camera.lookAt(0,0,0);
        
        // Recalc safe Z but negative
        const w = window.innerWidth, h = window.innerHeight;
        const aspect = w / h;
        const vFov = camera.fov * (Math.PI / 180);
        const fitH = 5.0 / Math.tan(vFov / 2);
        const fitW = 6.5 / (Math.tan(vFov / 2) * aspect);
        const safeZ = Math.max(12, fitH, fitW);
        camera.position.z = -safeZ;
    };

    let isLandscape = false;
    document.getElementById('btn-rotate').onclick = () => {
        isLandscape = !isLandscape;
        // Rotate Z to lay on side
        cardWrapper.rotation.z = isLandscape ? -Math.PI / 2 : 0;
    };

<\/script>
<div class="controls">
    <button id="btn-open">Open</button>
    <button id="btn-close">Close</button>
    <button id="btn-front">Front</button>
    <button id="btn-back">Back</button>
    <button id="btn-rotate">Rotate</button>
</div>
</body>
</html>`;
        }

        document.getElementById('btn-save-project').onclick = () => {
            // Create UI Overlay for Save
            const overlay = document.createElement('div');
            overlay.style.cssText = "position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.85); z-index:10000; display:flex; align-items:center; justify-content:center; font-family:sans-serif;";

            const box = document.createElement('div');
            box.style.cssText = "background:#333; padding:30px; border-radius:12px; border:1px solid #555; color:white; width:300px; display:flex; flex-direction:column; gap:15px; box-shadow:0 10px 30px rgba(0,0,0,0.5);";

            box.innerHTML = `
                <h3 style="margin:0; font-size:1.2rem;">Save Card</h3>
                <label style="font-size:0.9rem; color:#ccc;">Card Name:</label>
                <input type="text" id="save-card-name" value="My Card" style="padding:10px; border-radius:6px; border:1px solid #555; background:#222; color:white;">
                <div style="display:flex; justify-content:flex-end; gap:10px; margin-top:10px;">
                    <button id="btn-cancel-save" style="padding:8px 16px; background:transparent; border:1px solid #555; color:#ccc; border-radius:6px; cursor:pointer;">Cancel</button>
                    <button id="btn-confirm-save" style="padding:8px 16px; background:var(--accent-color); border:none; color:white; border-radius:6px; cursor:pointer; font-weight:bold;">Save</button>
                </div>
            `;

            overlay.appendChild(box);
            document.body.appendChild(overlay);

            const input = box.querySelector('#save-card-name');
            input.focus();
            input.select();

            const close = () => document.body.removeChild(overlay);

            box.querySelector('#btn-cancel-save').onclick = close;

            box.querySelector('#btn-confirm-save').onclick = () => {
                const name = input.value.trim() || "Untitled Card";

                const data = {
                    version: 1,
                    date: Date.now(),
                    outside: STATE.layers.outside.map(l => ({ ...l, imgElement: null })),
                    inside: STATE.layers.inside.map(l => ({ ...l, imgElement: null }))
                };

                try {
                    localStorage.setItem(`card_proj_${name}`, JSON.stringify(data));
                    // Simple toast instead of alert
                    const toast = document.createElement('div');
                    toast.innerText = `Saved "${name}"`;
                    toast.style.cssText = "position:fixed; bottom:20px; left:50%; transform:translateX(-50%); background:var(--accent-color); color:white; padding:10px 20px; border-radius:20px; font-family:sans-serif; z-index:10001; box-shadow:0 4px 12px rgba(0,0,0,0.5);";
                    document.body.appendChild(toast);
                    setTimeout(() => document.body.removeChild(toast), 3000);

                    close();
                } catch (e) {
                    alert("Save failed (Storage Full?): " + e.message);
                }
            };

            // Enter key support
            input.onkeydown = (e) => {
                if (e.key === 'Enter') box.querySelector('#btn-confirm-save').click();
                if (e.key === 'Escape') close();
            };
        };

        const btnNew = document.getElementById('btn-new-card');
        btnNew.onclick = () => {
            const isEmpty = STATE.layers.outside.length === 0 && STATE.layers.inside.length === 0;
            // Remove native confirm
            // if (!isEmpty && !confirm("Start new card? Unsaved changes will be lost.")) return;

            STATE.layers.outside = [];
            STATE.layers.inside = [];
            STATE.selectedElement = null;
            Canvas2D.render();

            // Simple toast
            const toast = document.createElement('div');
            toast.innerText = "New Card Started";
            toast.style.cssText = "position:fixed; bottom:20px; left:50%; transform:translateX(-50%); background:var(--accent-color); color:white; padding:10px 20px; border-radius:20px; font-family:sans-serif; z-index:10001;";
            document.body.appendChild(toast);
            setTimeout(() => document.body.removeChild(toast), 2000);
        };

        const btnCatalog = document.getElementById('btn-load-project');
        btnCatalog.innerText = "Load Card";

        btnCatalog.onclick = () => {
            // Create UI Overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = "position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.85); z-index:10000; display:flex; flex-direction:column; padding:40px; color:white; font-family:sans-serif;";

            const header = document.createElement('div');
            header.innerHTML = "<h2>Saved Cards Catalog</h2><p>Select a card to load (Unsaved changes will be lost):</p>";
            overlay.appendChild(header);



            const grid = document.createElement('div');
            grid.style.cssText = "display:grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap:20px; overflow-y:auto; padding:20px 0;";
            overlay.appendChild(grid);

            // Find Projects
            const keys = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith('card_proj_')) keys.push(key);
            }

            if (keys.length === 0) {
                grid.innerHTML = "<div>No saved projects found. Save one first!</div>";
            }

            keys.forEach(key => {
                const projName = key.replace('card_proj_', '');
                const raw = localStorage.getItem(key);
                let meta = {};
                try { meta = JSON.parse(raw); } catch (e) { }

                const cardir = document.createElement('div');
                cardir.style.cssText = "background:#333; border:1px solid #555; border-radius:8px; padding:15px; cursor:pointer; transition:0.2s;";
                cardir.innerHTML = `
                    <div style="font-weight:bold; font-size:1.1rem; margin-bottom:5px;">${projName}</div>
                    <div style="font-size:0.8rem; color:#aaa;">${new Date(meta.date || 0).toLocaleDateString()}</div>
                `;
                cardir.onmouseover = () => cardir.style.background = '#444';
                cardir.onmouseout = () => cardir.style.background = '#333';

                cardir.onclick = async () => {
                    const isEmpty = STATE.layers.outside.length === 0 && STATE.layers.inside.length === 0;
                    // Skip confirm to avoid browser blocking issues
                    // if (!isEmpty && !confirm(`Load "${projName}"? Unsaved changes will be lost.`)) return;

                    try {
                        const data = JSON.parse(localStorage.getItem(key));
                        // Rebuild state
                        STATE.layers.outside = await hydrateLayers(data.outside || []);
                        STATE.layers.inside = await hydrateLayers(data.inside || []);

                        STATE.selectedElement = null;
                        Canvas2D.render();
                        document.body.removeChild(overlay);
                    } catch (e) {
                        alert("Failed to load project: " + e.message);
                    }
                };

                // View Button
                const viewBtn = document.createElement('button');
                viewBtn.innerText = "👁️";
                viewBtn.title = "View Card";
                viewBtn.style.cssText = "float:right; background:transparent; border:none; color:#ddd; font-size:1.4rem; cursor:pointer; margin-top:-5px; margin-right: 10px; transition: color 0.2s;";
                viewBtn.onmouseover = () => viewBtn.style.color = 'white';
                viewBtn.onmouseout = () => viewBtn.style.color = '#ddd';

                viewBtn.onclick = async (e) => {
                    e.stopPropagation(); // Don't load the card
                    viewBtn.disabled = true;
                    viewBtn.innerText = "⌛";
                    try {
                        const data = JSON.parse(localStorage.getItem(key));
                        const { dataOut, dataIn } = await renderCardToDataUrls(data.outside || [], data.inside || []);
                        const html = getViewerHTML(dataOut, dataIn);
                        const blob = new Blob([html], { type: 'text/html' });
                        const url = URL.createObjectURL(blob);
                        window.open(url, '_blank');
                    } catch (err) {
                        alert("Failed to view: " + err.message);
                    } finally {
                        viewBtn.disabled = false;
                        viewBtn.innerText = "👁️";
                    }
                };
                cardir.insertBefore(viewBtn, cardir.firstChild);

                // Delete Button
                const delBtn = document.createElement('button');
                delBtn.innerText = "×";
                delBtn.title = "Delete Card";
                delBtn.style.cssText = "float:right; background:transparent; border:none; color:#f55; font-size:1.4rem; cursor:pointer; margin-top:-5px;";
                delBtn.onclick = (e) => {
                    e.stopPropagation();
                    if (delBtn.innerText === "×") {
                        delBtn.innerText = "Sure?";
                        delBtn.style.fontSize = "0.9rem";
                        delBtn.style.fontWeight = "bold";
                        setTimeout(() => {
                            if (cardir.parentElement) { // Check if still exists
                                delBtn.innerText = "×";
                                delBtn.style.fontSize = "1.4rem";
                            }
                        }, 3000);
                    } else {
                        localStorage.removeItem(key);
                        cardir.remove();
                    }
                };
                cardir.insertBefore(delBtn, cardir.firstChild);

                grid.appendChild(cardir);
            });

            const closeBtn = document.createElement('button');
            closeBtn.innerText = "Close Catalog";
            closeBtn.className = 'primary';
            closeBtn.style.cssText = "margin-top:auto; align-self:center; padding:10px 30px;";
            closeBtn.onclick = () => document.body.removeChild(overlay);
            overlay.appendChild(closeBtn);

            document.body.appendChild(overlay);
        };

        document.getElementById('btn-export-html').onclick = () => {
            // Remove confirm to avoid blocking
            // if (!confirm("This will download the card as a standalone HTML file which can be opened in any web browser.\n\nDo you want to continue?")) return;
            // Generate Texture Data URIs
            const dataOut = canvasOutside.toDataURL('image/jpeg', 0.8);
            const dataIn = canvasInside.toDataURL('image/jpeg', 0.8);

            // Minimal Viewer HTML
            const html = getViewerHTML(dataOut, dataIn);

            const blob = new Blob([html], { type: 'text/html' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'greeting_card.html';
            a.click();
        };

        // --- Auth UI Management ---
        const authContainer = document.getElementById('amplify-auth-container');
        const authStatus = document.getElementById('auth-status');
        const loginBtn = document.getElementById('btn-login-toggle');
        const closeAuthBtn = document.getElementById('btn-close-auth');

        const authTitle = document.getElementById('auth-title');
        const authToggleBtn = document.getElementById('auth-toggle-btn');
        const authToggleText = document.getElementById('auth-toggle-text');
        const authSubmitBtn = document.getElementById('btn-auth-submit');
        const authMsg = document.getElementById('auth-message');

        const fieldUser = document.getElementById('auth-username');
        const fieldEmail = document.getElementById('auth-email');
        const fieldPass = document.getElementById('auth-password');
        const fieldCode = document.getElementById('auth-code');

        let authMode = 'signin'; // signin, signup, confirm

        async function updateAuthUI() {
            try {
                const user = await getCurrentUser();
                const attributes = await fetchUserAttributes();
                const display = attributes.email || user.username;
                authStatus.innerHTML = `Signed in as:<br><strong>${display}</strong>`;
                loginBtn.innerText = "Sign Out";

            } catch (e) {
                authStatus.innerText = "Guest Mode";
                loginBtn.innerText = "Sign In to Cloud";
                loginBtn.innerText = "Sign In to Cloud";
            }
        }

        authToggleBtn.onclick = () => {
            authMsg.innerText = '';
            if (authMode === 'signin') {
                authMode = 'signup';
                authTitle.innerText = 'Create Account';
                authSubmitBtn.innerText = 'Create Account';
                authToggleText.innerText = 'Have an account?';
                authToggleBtn.innerText = 'Sign In';
                fieldUser.placeholder = 'Email';
                fieldCode.classList.add('hidden');
                fieldPass.classList.remove('hidden');
            } else {
                authMode = 'signin';
                authTitle.innerText = 'Sign In';
                authSubmitBtn.innerText = 'Sign In';
                authToggleText.innerText = 'Need an account?';
                authToggleBtn.innerText = 'Create Account';
                fieldUser.placeholder = 'Email';
                fieldCode.classList.add('hidden');
                fieldPass.classList.remove('hidden');
            }
        };

        authSubmitBtn.onclick = async () => {
            const username = fieldUser.value; // Now contains the Email
            const password = fieldPass.value;
            const code = fieldCode.value;

            authMsg.innerText = '';
            authSubmitBtn.disabled = true;
            const originalText = authSubmitBtn.innerText;
            authSubmitBtn.innerText = 'Please wait...';

            try {
                if (authMode === 'signin') {
                    const { nextStep } = await signIn({ username, password });

                    if (nextStep.signInStep === 'CONFIRM_SIGN_UP') {
                        authMode = 'confirm';
                        authTitle.innerText = 'Confirm Account';
                        authSubmitBtn.innerText = 'Confirm';
                        fieldCode.classList.remove('hidden');
                        fieldPass.classList.add('hidden');
                    } else {
                        authContainer.classList.add('hidden');
                        updateAuthUI();
                    }
                } else if (authMode === 'signup') {
                    await signUp({
                        username,
                        password,
                        options: {
                            userAttributes: { email: username }
                        }
                    });
                    authMode = 'confirm';
                    authTitle.innerText = 'Confirm Account';
                    authSubmitBtn.innerText = 'Confirm';
                    fieldCode.classList.remove('hidden');
                    fieldPass.classList.add('hidden');
                    authMsg.style.color = 'var(--accent-color)';
                    authMsg.innerText = 'Code sent to ' + username;
                } else if (authMode === 'confirm') {
                    await confirmSignUp({ username, confirmationCode: code });
                    await autoSignIn();
                    authContainer.classList.add('hidden');
                    updateAuthUI();
                }
            } catch (err) {
                console.error("Auth error:", err);
                authMsg.style.color = '#ff6b6b';
                authMsg.innerText = err.message || "An error occurred";
            } finally {
                authSubmitBtn.disabled = false;
                authSubmitBtn.innerText = originalText;
            }
        };

        loginBtn.onclick = async () => {
            if (loginBtn.innerText === "Sign Out") {
                await signOut();
                updateAuthUI();
            } else {
                authContainer.classList.remove('hidden');
            }
        };

        closeAuthBtn.onclick = () => authContainer.classList.add('hidden');

        // Close auth modal when signed in
        Hub.listen('auth', ({ payload }) => {
            if (payload.event === 'signedIn') {
                authContainer.classList.add('hidden');
            }
            updateAuthUI();
        });

        // Initialize UI
        updateAuthUI();

        // --- Cloud Gallery & Publishing Logic ---
        document.getElementById('btn-shared-cards').onclick = openSharedCardsModal;

        async function openSharedCardsModal() {
            // Create UI Overlay (Similar to Load Card)
            const overlay = document.createElement('div');
            overlay.style.cssText = "position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.85); z-index:10000; display:flex; flex-direction:column; padding:40px; color:white; font-family:sans-serif;";

            const header = document.createElement('div');
            header.innerHTML = "<h2>Shared Cards</h2><p>Click link to view card, or Trash to delete.</p>";
            overlay.appendChild(header);

            const grid = document.createElement('div');
            grid.style.cssText = "display:grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap:10px; overflow-y:auto; padding:20px 0;";
            overlay.appendChild(grid);

            // Loading state
            grid.innerHTML = '<div style="color:#aaa;">Loading cloud files...</div>';
            document.body.appendChild(overlay);

            // Close button helper
            const addCloseBtn = () => {
                const closeBtn = document.createElement('button');
                closeBtn.innerText = "Close";
                closeBtn.className = 'primary';
                closeBtn.style.cssText = "margin-top:auto; align-self:center; padding:10px 30px;";
                closeBtn.onclick = () => document.body.removeChild(overlay);
                overlay.appendChild(closeBtn);
            };

            try {
                const session = await fetchAuthSession();
                if (!session.tokens) {
                    grid.innerHTML = '<div style="color:#f55;">Please sign in to view shared cards.</div>';
                    addCloseBtn();
                    return;
                }

                const bucket = awsconfig.aws_user_files_s3_bucket;
                const region = awsconfig.aws_user_files_s3_bucket_region;

                const result = await list({
                    options: { accessLevel: 'guest' }
                });

                grid.innerHTML = '';
                if (result.items.length === 0) {
                    grid.innerHTML = '<div style="color:#aaa;">No cards found. Publish one first!</div>';
                }

                result.items.forEach(item => {
                    const itemEl = document.createElement('div');
                    itemEl.style.cssText = "display: flex; justify-content: space-between; align-items: center; background: #333; padding: 15px; border-radius: 8px; border: 1px solid #555; font-size: 1rem;";

                    const nameEl = document.createElement('span');
                    nameEl.innerText = item.key;
                    nameEl.style.cssText = "cursor: pointer; color: var(--accent-color); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex-grow: 1; font-weight:bold;";
                    nameEl.onclick = () => {
                        const url = `https://${bucket}.s3.${region}.amazonaws.com/public/${item.key}`;
                        window.open(url, '_blank');
                    };

                    const delBtn = document.createElement('button');
                    delBtn.innerText = '🗑️';
                    delBtn.style.cssText = "cursor: pointer; margin-left: 10px; background: transparent; border: none; font-size: 1.2rem;";
                    delBtn.onclick = async (e) => {
                        e.stopPropagation();

                        if (delBtn.innerText === '🗑️') {
                            delBtn.innerText = 'Sure?';
                            setTimeout(() => {
                                if (itemEl.parentElement) delBtn.innerText = '🗑️';
                            }, 3000);
                        } else {
                            delBtn.innerText = "⏳";
                            try {
                                await remove({ key: item.key, options: { accessLevel: 'guest' } });
                                itemEl.remove();
                            } catch (err) {
                                // alert("Failed to delete: " + err.message);
                                console.error(err);
                                delBtn.innerText = '🗑️';
                            }
                        }
                    };

                    itemEl.appendChild(nameEl);
                    itemEl.appendChild(delBtn);
                    grid.appendChild(itemEl);
                });

            } catch (error) {
                console.error("Error loading gallery:", error);
                grid.innerHTML = '<div style="color:#f55;">Error loading shared cards.</div>';
            }
            addCloseBtn();
        }

        Hub.listen('auth', ({ payload }) => {
            switch (payload.event) {
                case 'signedIn':
                    console.log('User signed in');
                    break;
                case 'signedOut':
                    break;
            }
        });

        async function generateHTMLString() {
            // Re-use logic from btn-export-html but return string instead of downloading
            const dataOut = canvasOutside.toDataURL('image/jpeg', 0.8);
            const dataIn = canvasInside.toDataURL('image/jpeg', 0.8);

            return `<!DOCTYPE html>
<html>
<head>
    <title>You've received a card!</title>
    <style>
        body{margin:0;overflow:hidden;background:#222;}
        .controls { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 100; display: flex; gap: 10px; }
        .controls button { background: rgba(0,0,0,0.6); color: white; border: 1px solid rgba(255,255,255,0.4); padding: 8px 16px; border-radius: 20px; cursor: pointer; font-family: sans-serif; font-size: 14px; transition: background 0.2s; }
        .controls button:hover { background: rgba(255,255,255,0.2); }
    </style>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"><\/script>
    <script type="importmap">{"imports":{"three":"https://unpkg.com/three@0.160.0/build/three.module.js"}}<\/script>
</head>
<body>
<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 100);
    
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // Responsive Logic
    function onWindowResize() {
        const w = window.innerWidth, h = window.innerHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
        
        const aspect = w / h;
        const vFov = camera.fov * (Math.PI / 180);
        const fitH = 5.0 / Math.tan(vFov / 2);
        const fitW = 6.5 / (Math.tan(vFov / 2) * aspect);
        const safeZ = Math.max(12, fitH, fitW);
        camera.position.z = safeZ;
        camera.position.y = 5;
    }
    window.addEventListener('resize', onWindowResize);
    onWindowResize();
    
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dl = new THREE.DirectionalLight(0xffffff, 0.8); dl.position.set(5,10,7); scene.add(dl);

    // Geometry
    const w=5.5, h=8.5;
    const gBase = new THREE.PlaneGeometry(w, h); // Base geometry
    const THICKNESS = 0.01;
    const OFFSET = w/2;

    // Materials
    const texOut = new THREE.TextureLoader().load('${dataOut}');
    const texIn = new THREE.TextureLoader().load('${dataIn}');
    texOut.colorSpace = THREE.SRGBColorSpace;
    texIn.colorSpace = THREE.SRGBColorSpace;
    
    const matOut = new THREE.MeshBasicMaterial({map:texOut, side:THREE.FrontSide});
    const matIn = new THREE.MeshBasicMaterial({map:texIn, side:THREE.FrontSide});

    const leftGroup = new THREE.Group();
    const rightGroup = new THREE.Group();
    const cardWrapper = new THREE.Group();
    scene.add(cardWrapper);
    cardWrapper.add(leftGroup);
    cardWrapper.add(rightGroup);

    // Front wing (Left) sits on top of Back wing (Right)
    leftGroup.position.z = THICKNESS * 2; 

    // scene.add(leftGroup); scene.add(rightGroup);
    
    // Helper
    function setUVs(geo, min, max) {
        const uvs = geo.attributes.uv;
        for(let i=0; i<uvs.count; i++){
            let u = uvs.getX(i);
            u = min + u * (max - min);
            uvs.setX(i, u);
        }
    }

    // Left Wing (Front Cover + Inside Left)
    const lIn = new THREE.Mesh(gBase.clone(), matIn); 
    lIn.position.set(-OFFSET, 0, THICKNESS);
    setUVs(lIn.geometry, 0, 0.5); // Inside Left
    leftGroup.add(lIn);
    
    const lOut = new THREE.Mesh(gBase.clone(), matOut); 
    lOut.position.set(-OFFSET, 0, -THICKNESS);
    lOut.rotation.y = Math.PI; 
    setUVs(lOut.geometry, 0.5, 1.0); // Fixed Front
    leftGroup.add(lOut);

    // Right Wing (Back Cover + Inside Right)
    const rIn = new THREE.Mesh(gBase.clone(), matIn); 
    rIn.position.set(OFFSET, 0, THICKNESS);
    setUVs(rIn.geometry, 0.5, 1.0);
    rightGroup.add(rIn);
    
    const rOut = new THREE.Mesh(gBase.clone(), matOut); 
    rOut.position.set(OFFSET, 0, -THICKNESS);
    rOut.rotation.y = Math.PI; 
    setUVs(rOut.geometry, 0.0, 0.5); // Fixed Back
    rightGroup.add(rOut);
    
    // Interaction State
    const CLOSED_ANGLE = Math.PI * 0.9; // 90% Closed
    const OPEN_ANGLE = Math.PI * 0.1;   // 90% Open
    let targetAngle = CLOSED_ANGLE; 
    leftGroup.rotation.y = CLOSED_ANGLE;

    let isDragging = false;
    document.addEventListener('mousedown', () => isDragging = false);
    document.addEventListener('mousemove', () => isDragging = true);
    document.addEventListener('mouseup', (e) => {
        if (e.target.closest && e.target.closest('.controls')) return;
        if (!isDragging) {
             targetAngle = (targetAngle === CLOSED_ANGLE) ? OPEN_ANGLE : CLOSED_ANGLE;
        }
    });

    function animate() {
        requestAnimationFrame(animate);
        // Smooth Lerp
        leftGroup.rotation.y += (targetAngle - leftGroup.rotation.y) * 0.05;
        controls.update();
        renderer.render(scene, camera);
    }
    animate();

    // UI Logic
    document.getElementById('btn-open').onclick = () => targetAngle = OPEN_ANGLE;
    document.getElementById('btn-close').onclick = () => targetAngle = CLOSED_ANGLE;

    document.getElementById('btn-front').onclick = () => {
        controls.reset();
        camera.position.set(0, 0, 15);
        camera.lookAt(0,0,0);
        onWindowResize(); 
    };

    document.getElementById('btn-back').onclick = () => {
        controls.reset();
        camera.position.set(0, 0, -15);
        camera.lookAt(0,0,0);
        // Recalc safe Z but negative
        const w = window.innerWidth, h = window.innerHeight;
        const aspect = w / h;
        const vFov = camera.fov * (Math.PI / 180);
        const fitH = 5.0 / Math.tan(vFov / 2);
        const fitW = 6.5 / (Math.tan(vFov / 2) * aspect);
        const safeZ = Math.max(12, fitH, fitW);
        camera.position.z = -safeZ;
    };

    let isLandscape = false;
    document.getElementById('btn-rotate').onclick = () => {
        isLandscape = !isLandscape;
        cardWrapper.rotation.z = isLandscape ? -Math.PI / 2 : 0;
    };
<\/script>
<div class="controls">
    <button id="btn-open">Open</button>
    <button id="btn-close">Close</button>
    <button id="btn-front">Front</button>
    <button id="btn-back">Back</button>
    <button id="btn-rotate">Rotate</button>
</div>
</body>
</html>`;
        }

        document.getElementById('btn-publish-cloud').onclick = async () => {
            const btn = document.getElementById('btn-publish-cloud');
            const originalText = btn.innerText;
            btn.innerText = "⏳ Publishing...";
            btn.disabled = true;

            try {
                // Force session refresh before upload to avoid unauthRole error
                const session = await fetchAuthSession({ forceRefresh: true });
                if (!session.tokens) {
                    throw new Error("You must be signed in to publish to the cloud.");
                }

                const htmlString = await generateHTMLString();
                const key = `card-${Date.now()}.html`;

                await uploadData({
                    key: key,
                    data: htmlString,
                    options: {
                        accessLevel: 'guest',
                        contentType: 'text/html'
                    }
                }).result;

                alert("Card Published!");
            } catch (error) {
                console.error("Publish error:", error);
                alert("Failed to publish card: " + error.message);
            } finally {
                btn.innerText = originalText;
                btn.disabled = false;
            }
        };

        // --- Render Loop ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // Fix for initial load race condition or context loss
            // We force update textures if they haven't been rendered yet
            if (renderer.info.render.frame % 30 === 0) {
                texOutside.needsUpdate = true;
                texInside.needsUpdate = true;
            }

            renderer.render(scene, camera);
        }
        animate();

        // Initial State
        // Add timeout to ensure fonts/images are ready
        setTimeout(() => {
            updateFold(0.5);
            Canvas2D.render();
        }, 500);
    </script>
    <div id="amplify-auth-container" class="hidden"
        style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 10000; background: var(--bg-color); padding: 40px; border-radius: 12px; border: 1px solid var(--panel-border); box-shadow: 0 10px 40px rgba(0,0,0,0.8); min-width: 350px;">
        <button id="btn-close-auth"
            style="position: absolute; right: 15px; top: 15px; background: transparent; border: none; font-size: 1.2rem; cursor: pointer; color: #fff;">×</button>

        <div id="auth-form-wrapper">
            <h2 id="auth-title" style="margin-bottom: 20px; font-size: 1.2rem; text-align: center;">Sign In</h2>

            <div id="auth-inputs" style="display: flex; flex-direction: column; gap: 15px;">
                <input type="email" id="auth-username" placeholder="Email"
                    style="background: rgba(0,0,0,0.3); border: 1px solid var(--panel-border); color: white; padding: 10px; border-radius: 6px;">
                <input type="password" id="auth-password" placeholder="Password"
                    style="background: rgba(0,0,0,0.3); border: 1px solid var(--panel-border); color: white; padding: 10px; border-radius: 6px;">
                <input type="text" id="auth-code" class="hidden" placeholder="Confirmation Code"
                    style="background: rgba(0,0,0,0.3); border: 1px solid var(--panel-border); color: white; padding: 10px; border-radius: 6px;">
            </div>

            <button id="btn-auth-submit" class="primary" style="width: 100%; margin-top: 20px; padding: 12px;">Sign
                In</button>

            <div id="auth-toggle-wrapper"
                style="margin-top: 15px; text-align: center; font-size: 0.85rem; color: var(--text-sec);">
                <span id="auth-toggle-text">Need an account?</span>
                <span id="auth-toggle-btn"
                    style="color: var(--accent-color); cursor: pointer; margin-left: 5px; font-weight: 500;">Create
                    Account</span>
            </div>

            <div id="auth-message" style="margin-top: 15px; font-size: 0.85rem; text-align: center; color: #ff6b6b;">
            </div>
        </div>
    </div>
    <!-- Shape Modal -->
    <div id="modal-shapes" class="hidden"
        style="position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:5000; display:flex; align-items:center; justify-content:center;">
        <div
            style="background:var(--panel-bg); backdrop-filter:blur(20px); border:1px solid var(--panel-border); padding:20px; border-radius:12px; width:300px;">
            <h3 style="margin-top:0;">Select Shape</h3>
            <div style="display:grid; grid-template-columns: repeat(3, 1fr); gap:10px; margin-bottom:20px;">
                <button class="shape-opt" data-shape="rect" style="height:60px; font-size:2rem;">⬛</button>
                <button class="shape-opt" data-shape="circle" style="height:60px; font-size:2rem;">⚫</button>
                <button class="shape-opt" data-shape="triangle" style="height:60px; font-size:2rem;">🔺</button>
                <button class="shape-opt" data-shape="star" style="height:60px; font-size:2rem;">⭐</button>
                <button class="shape-opt" data-shape="heart" style="height:60px; font-size:2rem;">❤️</button>
            </div>
            <button id="btn-close-shapes" style="width:100%;">Cancel</button>
        </div>
    </div>

    <!-- Sticker Modal -->
    <div id="modal-stickers" class="hidden"
        style="position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:5000; display:flex; align-items:center; justify-content:center;">
        <div
            style="background:var(--panel-bg); backdrop-filter:blur(20px); border:1px solid var(--panel-border); padding:20px; border-radius:12px; width:400px; height:500px; display:flex; flex-direction:column;">
            <h3 style="margin-top:0;">Add Sticker</h3>

            <div
                style="display:flex; gap:10px; margin-bottom:15px; border-bottom:1px solid rgba(255,255,255,0.1); padding-bottom:10px;">
                <button id="tab-general" class="view-btn active" style="flex:1;">General</button>
                <button id="tab-upload" class="view-btn" style="flex:1;">Upload</button>
            </div>

            <div id="sticker-content-general"
                style="flex:1; overflow-y:auto; display:grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap:10px;">
                <!-- Populated via JS -->
            </div>

            <div id="sticker-content-upload" class="hidden"
                style="flex:1; display:flex; flex-direction:column; align-items:center; justify-content:center; text-align:center; color:#aaa;">
                <p>Upload your own sticker image (PNG/JPG)</p>
                <input type="file" id="sticker-upload-input" accept="image/*" style="display:block; margin-top:10px;">
                <p style="font-size:0.8rem; margin-top:20px;">Images will be scaled down to fit the card.</p>
            </div>

            <button id="btn-close-stickers" style="margin-top:20px; width:100%;">Close</button>
        </div>
    </div>
</body>

</html>